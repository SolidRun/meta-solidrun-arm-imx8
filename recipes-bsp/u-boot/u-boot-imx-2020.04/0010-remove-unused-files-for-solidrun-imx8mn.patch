From 16687eb3b761512ee28ae3b8e4e927888f3126a3 Mon Sep 17 00:00:00 2001
From: Yazan Shhady <yazan.shhady@solid-run.com>
Date: Mon, 5 Jul 2021 17:12:18 +0300
Subject: [PATCH] remove unused files for solidrun imx8mn

---
 board/solidrun/common/Makefile                |    8 -
 board/solidrun/common/eeprom.h                |   33 -
 board/solidrun/common/sys_eeprom.c            |  620 ----------
 board/solidrun/common/tcpc.c                  | 1017 -----------------
 board/solidrun/common/tcpc.h                  |  469 --------
 board/solidrun/common/tlv_data.c              |  102 --
 board/solidrun/common/tlv_data.h              |   18 -
 .../imx8mn_solidrun/imx8mn_solidrun.c         |  181 +--
 configs/imx8mn_solidrun_defconfig             |    5 -
 9 files changed, 1 insertion(+), 2452 deletions(-)
 delete mode 100644 board/solidrun/common/eeprom.h
 delete mode 100644 board/solidrun/common/sys_eeprom.c
 delete mode 100644 board/solidrun/common/tcpc.c
 delete mode 100644 board/solidrun/common/tcpc.h
 delete mode 100644 board/solidrun/common/tlv_data.c
 delete mode 100644 board/solidrun/common/tlv_data.h

diff --git a/board/solidrun/common/Makefile b/board/solidrun/common/Makefile
index 5600fce670..c6d7a800c2 100644
--- a/board/solidrun/common/Makefile
+++ b/board/solidrun/common/Makefile
@@ -25,9 +25,6 @@ endif
 obj-$(CONFIG_VID)		+= vid.o
 obj-$(CONFIG_FSL_QIXIS)	+= qixis.o
 obj-$(CONFIG_PQ_MDS_PIB)	+= pq-mds-pib.o
-ifndef CONFIG_SPL_BUILD
-obj-$(CONFIG_ID_EEPROM)	+= sys_eeprom.o
-endif
 obj-$(CONFIG_FSL_SGMII_RISER)	+= sgmii_riser.o
 ifndef CONFIG_RAMBOOT_PBL
 obj-$(CONFIG_FSL_FIXED_MMC_LOCATION)	+= sdhc_boot.o
@@ -41,7 +38,6 @@ else
 obj-$(CONFIG_DEEP_SLEEP)		+= mpc85xx_sleep.o
 endif
 
-obj-$(CONFIG_TARGET_CLEARFOG) += tlv_data.o
 obj-$(CONFIG_FSL_DCU_SII9022A)    += dcu_sii9022a.o
 
 obj-$(CONFIG_TARGET_MPC8541CDS)	+= cds_pci_ft.o
@@ -86,8 +82,4 @@ obj-$(CONFIG_CMD_ESBC_VALIDATE) += fsl_validate.o cmd_esbc_validate.o
 endif
 obj-$(CONFIG_CHAIN_OF_TRUST) += fsl_chain_of_trust.o
 
-ifndef CONFIG_SPL_BUILD
-obj-$(CONFIG_USB_TCPC) += tcpc.o
-endif
-
 endif
diff --git a/board/solidrun/common/eeprom.h b/board/solidrun/common/eeprom.h
deleted file mode 100644
index 328fd3974b..0000000000
--- a/board/solidrun/common/eeprom.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright 2004 Freescale Semiconductor.
- */
-
-#ifndef __EEPROM_H_
-#define __EEPROM_H_
-
-
-/*
- * EEPROM Board System Register interface.
- */
-
-
-/*
- * CPU Board Revision
- */
-#define MPC85XX_CPU_BOARD_REV(maj, min)	((((maj)&0xff) << 8) | ((min) & 0xff))
-#define MPC85XX_CPU_BOARD_MAJOR(rev)	(((rev) >> 8) & 0xff)
-#define MPC85XX_CPU_BOARD_MINOR(rev)	((rev) & 0xff)
-
-#define MPC85XX_CPU_BOARD_REV_UNKNOWN	MPC85XX_CPU_BOARD_REV(0,0)
-#define MPC85XX_CPU_BOARD_REV_1_0	MPC85XX_CPU_BOARD_REV(1,0)
-#define MPC85XX_CPU_BOARD_REV_1_1	MPC85XX_CPU_BOARD_REV(1,1)
-
-/*
- * Returns CPU board revision register as a 16-bit value with
- * the Major in the high byte, and Minor in the low byte.
- */
-extern unsigned int get_cpu_board_revision(void);
-
-
-#endif	/* __CADMUS_H_ */
diff --git a/board/solidrun/common/sys_eeprom.c b/board/solidrun/common/sys_eeprom.c
deleted file mode 100644
index 6f151b0f71..0000000000
--- a/board/solidrun/common/sys_eeprom.c
+++ /dev/null
@@ -1,620 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright 2006, 2008-2009, 2011 Freescale Semiconductor
- * York Sun (yorksun@freescale.com)
- * Haiying Wang (haiying.wang@freescale.com)
- * Timur Tabi (timur@freescale.com)
- */
-
-#include <common.h>
-#include <command.h>
-#include <env.h>
-#include <i2c.h>
-#include <linux/ctype.h>
-#include <u-boot/crc.h>
-
-#ifdef CONFIG_SYS_I2C_EEPROM_CCID
-#include "../common/eeprom.h"
-#define MAX_NUM_PORTS	8
-#endif
-
-#ifdef CONFIG_SYS_I2C_EEPROM_NXID
-/* some boards with non-256-bytes EEPROM have special define */
-/* for MAX_NUM_PORTS in board-specific file */
-#ifndef MAX_NUM_PORTS
-#define MAX_NUM_PORTS	16
-#endif
-#define NXID_VERSION	1
-#endif
-
-/**
- * static eeprom: EEPROM layout for CCID or NXID formats
- *
- * See application note AN3638 for details.
- */
-static struct __attribute__ ((__packed__)) eeprom {
-#ifdef CONFIG_SYS_I2C_EEPROM_CCID
-	u8 id[4];         /* 0x00 - 0x03 EEPROM Tag 'CCID' */
-	u8 major;         /* 0x04        Board revision, major */
-	u8 minor;         /* 0x05        Board revision, minor */
-	u8 sn[10];        /* 0x06 - 0x0F Serial Number*/
-	u8 errata[2];     /* 0x10 - 0x11 Errata Level */
-	u8 date[6];       /* 0x12 - 0x17 Build Date */
-	u8 res_0[40];     /* 0x18 - 0x3f Reserved */
-	u8 mac_count;     /* 0x40        Number of MAC addresses */
-	u8 mac_flag;      /* 0x41        MAC table flags */
-	u8 mac[MAX_NUM_PORTS][6];     /* 0x42 - 0x71 MAC addresses */
-	u32 crc;          /* 0x72        CRC32 checksum */
-#endif
-#ifdef CONFIG_SYS_I2C_EEPROM_NXID
-	u8 id[4];         /* 0x00 - 0x03 EEPROM Tag 'NXID' */
-	u8 sn[12];        /* 0x04 - 0x0F Serial Number */
-	u8 errata[5];     /* 0x10 - 0x14 Errata Level */
-	u8 date[6];       /* 0x15 - 0x1a Build Date */
-	u8 res_0;         /* 0x1b        Reserved */
-	u32 version;      /* 0x1c - 0x1f NXID Version */
-	u8 tempcal[8];    /* 0x20 - 0x27 Temperature Calibration Factors */
-	u8 tempcalsys[2]; /* 0x28 - 0x29 System Temperature Calibration Factors */
-	u8 tempcalflags;  /* 0x2a        Temperature Calibration Flags */
-	u8 res_1[21];     /* 0x2b - 0x3f Reserved */
-	u8 mac_count;     /* 0x40        Number of MAC addresses */
-	u8 mac_flag;      /* 0x41        MAC table flags */
-	u8 mac[MAX_NUM_PORTS][6];     /* 0x42 - 0xa1 MAC addresses */
-	u8 res_2[90];     /* 0xa2 - 0xfb Reserved */	
-	u32 crc;          /* 0xfc - 0xff CRC32 checksum */
-#endif
-} e;
-
-/* Set to 1 if we've read EEPROM into memory */
-static int has_been_read = 0;
-
-#ifdef CONFIG_SYS_I2C_EEPROM_NXID
-/* Is this a valid NXID EEPROM? */
-#define is_valid ((e.id[0] == 'N') || (e.id[1] == 'X') || \
-		  (e.id[2] == 'I') || (e.id[3] == 'D'))
-#endif
-
-#ifdef CONFIG_SYS_I2C_EEPROM_CCID
-/* Is this a valid CCID EEPROM? */
-#define is_valid ((e.id[0] == 'C') || (e.id[1] == 'C') || \
-		  (e.id[2] == 'I') || (e.id[3] == 'D'))
-#endif
-
-/**
- * show_eeprom - display the contents of the EEPROM
- */
-static void show_eeprom(void)
-{
-	int i;
-	unsigned int crc;
-
-	/* EEPROM tag ID, either CCID or NXID */
-#ifdef CONFIG_SYS_I2C_EEPROM_NXID
-	printf("ID: %c%c%c%c v%u\n", e.id[0], e.id[1], e.id[2], e.id[3],
-	       be32_to_cpu(e.version));
-#else
-	printf("ID: %c%c%c%c\n", e.id[0], e.id[1], e.id[2], e.id[3]);
-#endif
-
-	/* Serial number */
-	printf("SN: %s\n", e.sn);
-
-	/* Errata level. */
-#ifdef CONFIG_SYS_I2C_EEPROM_NXID
-	printf("Errata: %s\n", e.errata);
-#else
-	printf("Errata: %c%c\n",
-		e.errata[0] ? e.errata[0] : '.',
-		e.errata[1] ? e.errata[1] : '.');
-#endif
-
-	/* Build date, BCD date values, as YYMMDDhhmmss */
-	printf("Build date: 20%02x/%02x/%02x %02x:%02x:%02x %s\n",
-		e.date[0], e.date[1], e.date[2],
-		e.date[3] & 0x7F, e.date[4], e.date[5],
-		e.date[3] & 0x80 ? "PM" : "");
-
-	/* Show MAC addresses  */
-	for (i = 0; i < min(e.mac_count, (u8)MAX_NUM_PORTS); i++) {
-
-		u8 *p = e.mac[i];
-
-		printf("Eth%u: %02x:%02x:%02x:%02x:%02x:%02x\n", i,
-			p[0], p[1], p[2], p[3],	p[4], p[5]);
-	}
-
-	crc = crc32(0, (void *)&e, sizeof(e) - 4);
-
-	if (crc == be32_to_cpu(e.crc))
-		printf("CRC: %08x\n", be32_to_cpu(e.crc));
-	else
-		printf("CRC: %08x (should be %08x)\n",
-			be32_to_cpu(e.crc), crc);
-
-#ifdef DEBUG
-	printf("EEPROM dump: (0x%x bytes)\n", sizeof(e));
-	for (i = 0; i < sizeof(e); i++) {
-		if ((i % 16) == 0)
-			printf("%02X: ", i);
-		printf("%02X ", ((u8 *)&e)[i]);
-		if (((i % 16) == 15) || (i == sizeof(e) - 1))
-			printf("\n");
-	}
-#endif
-}
-
-/**
- * read_eeprom - read the EEPROM into memory
- */
-static int read_eeprom(void)
-{
-	int ret;
-#ifdef CONFIG_SYS_EEPROM_BUS_NUM
-#ifndef CONFIG_DM_I2C
-	unsigned int bus;
-#endif
-#endif
-
-	if (has_been_read)
-		return 0;
-
-#ifdef CONFIG_SYS_EEPROM_BUS_NUM
-#ifndef CONFIG_DM_I2C
-	bus = i2c_get_bus_num();
-	i2c_set_bus_num(CONFIG_SYS_EEPROM_BUS_NUM);
-#endif
-#endif
-
-#ifndef CONFIG_DM_I2C
-	ret = i2c_read(CONFIG_SYS_I2C_EEPROM_ADDR, 0,
-		       CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
-		       (void *)&e, sizeof(e));
-#else
-	struct udevice *dev;
-#ifdef CONFIG_SYS_EEPROM_BUS_NUM
-	ret = i2c_get_chip_for_busnum(CONFIG_SYS_EEPROM_BUS_NUM,
-				      CONFIG_SYS_I2C_EEPROM_ADDR, 1, &dev);
-#else
-	ret = i2c_get_chip_for_busnum(0, CONFIG_SYS_I2C_EEPROM_ADDR, 1, &dev);
-#endif
-	if (!ret)
-		ret = dm_i2c_read(dev, 0, (void *)&e, sizeof(e));
-#endif
-
-#ifdef CONFIG_SYS_EEPROM_BUS_NUM
-#ifndef CONFIG_DM_I2C
-	i2c_set_bus_num(bus);
-#endif
-#endif
-
-#ifdef DEBUG
-	show_eeprom();
-#endif
-
-	has_been_read = (ret == 0) ? 1 : 0;
-
-	return ret;
-}
-
-/**
- *  update_crc - update the CRC
- *
- *  This function should be called after each update to the EEPROM structure,
- *  to make sure the CRC is always correct.
- */
-static void update_crc(void)
-{
-	u32 crc;
-
-	crc = crc32(0, (void *)&e, sizeof(e) - 4);
-	e.crc = cpu_to_be32(crc);
-}
-
-/**
- * prog_eeprom - write the EEPROM from memory
- */
-static int prog_eeprom(void)
-{
-	int ret = 0;
-	int i;
-	void *p;
-#ifdef CONFIG_SYS_EEPROM_BUS_NUM
-#ifndef CONFIG_DM_I2C
-	unsigned int bus;
-#endif
-#endif
-
-	/* Set the reserved values to 0xFF   */
-#ifdef CONFIG_SYS_I2C_EEPROM_NXID
-	e.res_0 = 0xFF;
-	memset(e.res_1, 0xFF, sizeof(e.res_1));
-#else
-	memset(e.res_0, 0xFF, sizeof(e.res_0));
-#endif
-	update_crc();
-
-#ifndef CONFIG_DM_I2C
-#ifdef CONFIG_SYS_EEPROM_BUS_NUM
-	bus = i2c_get_bus_num();
-	i2c_set_bus_num(CONFIG_SYS_EEPROM_BUS_NUM);
-#endif
-#endif
-
-	/*
-	 * The AT24C02 datasheet says that data can only be written in page
-	 * mode, which means 8 bytes at a time, and it takes up to 5ms to
-	 * complete a given write.
-	 */
-	for (i = 0, p = &e; i < sizeof(e); i += 8, p += 8) {
-#ifndef CONFIG_DM_I2C
-		ret = i2c_write(CONFIG_SYS_I2C_EEPROM_ADDR, i,
-				CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
-				p, min((int)(sizeof(e) - i), 8));
-#else
-		struct udevice *dev;
-#ifdef CONFIG_SYS_EEPROM_BUS_NUM
-		ret = i2c_get_chip_for_busnum(CONFIG_SYS_EEPROM_BUS_NUM,
-					      CONFIG_SYS_I2C_EEPROM_ADDR,
-					      CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
-					      &dev);
-#else
-		ret = i2c_get_chip_for_busnum(0, CONFIG_SYS_I2C_EEPROM_ADDR,
-					      CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
-					      &dev);
-#endif
-		if (!ret)
-			ret = dm_i2c_write(dev, i, p, min((int)(sizeof(e) - i),
-							  8));
-#endif
-		if (ret)
-			break;
-		udelay(5000);	/* 5ms write cycle timing */
-	}
-
-	if (!ret) {
-		/* Verify the write by reading back the EEPROM and comparing */
-		struct eeprom e2;
-
-#ifndef CONFIG_DM_I2C
-		ret = i2c_read(CONFIG_SYS_I2C_EEPROM_ADDR, 0,
-			       CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
-			       (void *)&e2, sizeof(e2));
-#else
-		struct udevice *dev;
-#ifdef CONFIG_SYS_EEPROM_BUS_NUM
-		ret = i2c_get_chip_for_busnum(CONFIG_SYS_EEPROM_BUS_NUM,
-					      CONFIG_SYS_I2C_EEPROM_ADDR,
-					      CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
-					      &dev);
-#else
-		ret = i2c_get_chip_for_busnum(0, CONFIG_SYS_I2C_EEPROM_ADDR,
-					      CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
-					      &dev);
-#endif
-		if (!ret)
-			ret = dm_i2c_read(dev, 0, (void *)&e2, sizeof(e2));
-#endif
-		if (!ret && memcmp(&e, &e2, sizeof(e)))
-			ret = -1;
-	}
-
-#ifndef CONFIG_DM_I2C
-#ifdef CONFIG_SYS_EEPROM_BUS_NUM
-	i2c_set_bus_num(bus);
-#endif
-#endif
-
-	if (ret) {
-		printf("Programming failed.\n");
-		has_been_read = 0;
-		return -1;
-	}
-
-	printf("Programming passed.\n");
-	return 0;
-}
-
-/**
- * h2i - converts hex character into a number
- *
- * This function takes a hexadecimal character (e.g. '7' or 'C') and returns
- * the integer equivalent.
- */
-static inline u8 h2i(char p)
-{
-	if ((p >= '0') && (p <= '9'))
-		return p - '0';
-
-	if ((p >= 'A') && (p <= 'F'))
-		return (p - 'A') + 10;
-
-	if ((p >= 'a') && (p <= 'f'))
-		return (p - 'a') + 10;
-
-	return 0;
-}
-
-/**
- * set_date - stores the build date into the EEPROM
- *
- * This function takes a pointer to a string in the format "YYMMDDhhmmss"
- * (2-digit year, 2-digit month, etc), converts it to a 6-byte BCD string,
- * and stores it in the build date field of the EEPROM local copy.
- */
-static void set_date(const char *string)
-{
-	unsigned int i;
-
-	if (strlen(string) != 12) {
-		printf("Usage: mac date YYMMDDhhmmss\n");
-		return;
-	}
-
-	for (i = 0; i < 6; i++)
-		e.date[i] = h2i(string[2 * i]) << 4 | h2i(string[2 * i + 1]);
-
-	update_crc();
-}
-
-/**
- * set_mac_address - stores a MAC address into the EEPROM
- *
- * This function takes a pointer to MAC address string
- * (i.e."XX:XX:XX:XX:XX:XX", where "XX" is a two-digit hex number) and
- * stores it in one of the MAC address fields of the EEPROM local copy.
- */
-static void set_mac_address(unsigned int index, const char *string)
-{
-	char *p = (char *) string;
-	unsigned int i;
-
-	if ((index >= MAX_NUM_PORTS) || !string) {
-		printf("Usage: mac <n> XX:XX:XX:XX:XX:XX\n");
-		return;
-	}
-
-	for (i = 0; *p && (i < 6); i++) {
-		e.mac[index][i] = simple_strtoul(p, &p, 16);
-		if (*p == ':')
-			p++;
-	}
-
-	update_crc();
-}
-
-int do_mac(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
-{
-	char cmd;
-
-	if (argc == 1) {
-		show_eeprom();
-		return 0;
-	}
-
-	cmd = argv[1][0];
-
-	if (cmd == 'r') {
-		read_eeprom();
-		return 0;
-	}
-
-	if (cmd == 'i') {
-#ifdef CONFIG_SYS_I2C_EEPROM_NXID
-		memcpy(e.id, "NXID", sizeof(e.id));
-		e.version = cpu_to_be32(NXID_VERSION);
-#else
-		memcpy(e.id, "CCID", sizeof(e.id));
-#endif
-		update_crc();
-		return 0;
-	}
-
-	if (!is_valid) {
-		printf("Please read the EEPROM ('r') and/or set the ID ('i') first.\n");
-		return 0;
-	}
-
-	if (argc == 2) {
-		switch (cmd) {
-		case 's':	/* save */
-			prog_eeprom();
-			break;
-		default:
-			return cmd_usage(cmdtp);
-		}
-
-		return 0;
-	}
-
-	/* We know we have at least one parameter  */
-
-	switch (cmd) {
-	case 'n':	/* serial number */
-		memset(e.sn, 0, sizeof(e.sn));
-		strncpy((char *)e.sn, argv[2], sizeof(e.sn) - 1);
-		update_crc();
-		break;
-	case 'e':	/* errata */
-#ifdef CONFIG_SYS_I2C_EEPROM_NXID
-		memset(e.errata, 0, 5);
-		strncpy((char *)e.errata, argv[2], 4);
-#else
-		e.errata[0] = argv[2][0];
-		e.errata[1] = argv[2][1];
-#endif
-		update_crc();
-		break;
-	case 'd':	/* date BCD format YYMMDDhhmmss */
-		set_date(argv[2]);
-		break;
-	case 'p':	/* MAC table size */
-		e.mac_count = simple_strtoul(argv[2], NULL, 16);
-		update_crc();
-		break;
-	case '0' ... '9':	/* "mac 0" through "mac 22" */
-		set_mac_address(simple_strtoul(argv[1], NULL, 10), argv[2]);
-		break;
-	case 'h':	/* help */
-	default:
-		return cmd_usage(cmdtp);
-	}
-
-	return 0;
-}
-
-/**
- * mac_read_from_eeprom - read the MAC addresses from EEPROM
- *
- * This function reads the MAC addresses from EEPROM and sets the
- * appropriate environment variables for each one read.
- *
- * The environment variables are only set if they haven't been set already.
- * This ensures that any user-saved variables are never overwritten.
- *
- * This function must be called after relocation.
- *
- * For NXID v1 EEPROMs, we support loading and up-converting the older NXID v0
- * format.  In a v0 EEPROM, there are only eight MAC addresses and the CRC is
- * located at a different offset.
- */
-int mac_read_from_eeprom(void)
-{
-	unsigned int i;
-	u32 crc, crc_offset = offsetof(struct eeprom, crc);
-	u32 *crcp; /* Pointer to the CRC in the data read from the EEPROM */
-
-	puts("EEPROM: ");
-
-	if (read_eeprom()) {
-		printf("Read failed.\n");
-		return 0;
-	}
-
-	if (!is_valid) {
-		printf("Invalid ID (%02x %02x %02x %02x)\n",
-		       e.id[0], e.id[1], e.id[2], e.id[3]);
-		return 0;
-	}
-
-#ifdef CONFIG_SYS_I2C_EEPROM_NXID
-	/*
-	 * If we've read an NXID v0 EEPROM, then we need to set the CRC offset
-	 * to where it is in v0.
-	 */
-	if (e.version == 0)
-		crc_offset = 0x72;
-#endif
-
-	crc = crc32(0, (void *)&e, crc_offset);
-	crcp = (void *)&e + crc_offset;
-	if (crc != be32_to_cpu(*crcp)) {
-		printf("CRC mismatch (%08x != %08x)\n", crc, be32_to_cpu(e.crc));
-		return 0;
-	}
-
-#ifdef CONFIG_SYS_I2C_EEPROM_NXID
-	/*
-	 * MAC address #9 in v1 occupies the same position as the CRC in v0.
-	 * Erase it so that it's not mistaken for a MAC address.  We'll
-	 * update the CRC later.
-	 */
-	if (e.version == 0)
-		memset(e.mac[8], 0xff, 6);
-#endif
-
-	for (i = 0; i < min(e.mac_count, (u8)MAX_NUM_PORTS); i++) {
-		if (memcmp(&e.mac[i], "\0\0\0\0\0\0", 6) &&
-		    memcmp(&e.mac[i], "\xFF\xFF\xFF\xFF\xFF\xFF", 6)) {
-			char ethaddr[18];
-			char enetvar[9];
-
-			sprintf(ethaddr, "%02X:%02X:%02X:%02X:%02X:%02X",
-				e.mac[i][0],
-				e.mac[i][1],
-				e.mac[i][2],
-				e.mac[i][3],
-				e.mac[i][4],
-				e.mac[i][5]);
-			sprintf(enetvar, i ? "eth%daddr" : "ethaddr", i);
-			/* Only initialize environment variables that are blank
-			 * (i.e. have not yet been set)
-			 */
-			if (!env_get(enetvar))
-				env_set(enetvar, ethaddr);
-		}
-	}
-
-#ifdef CONFIG_SYS_I2C_EEPROM_NXID
-	printf("%c%c%c%c v%u\n", e.id[0], e.id[1], e.id[2], e.id[3],
-	       be32_to_cpu(e.version));
-#else
-	printf("%c%c%c%c\n", e.id[0], e.id[1], e.id[2], e.id[3]);
-#endif
-
-#ifdef CONFIG_SYS_I2C_EEPROM_NXID
-	/*
-	 * Now we need to upconvert the data into v1 format.  We do this last so
-	 * that at boot time, U-Boot will still say "NXID v0".
-	 */
-	if (e.version == 0) {
-		e.version = cpu_to_be32(NXID_VERSION);
-		update_crc();
-	}
-#endif
-
-	return 0;
-}
-
-#ifdef CONFIG_SYS_I2C_EEPROM_CCID
-
-/**
- * get_cpu_board_revision - get the CPU board revision on 85xx boards
- *
- * Read the EEPROM to determine the board revision.
- *
- * This function is called before relocation, so we need to read a private
- * copy of the EEPROM into a local variable on the stack.
- *
- * Also, we assume that CONFIG_SYS_EEPROM_BUS_NUM == CONFIG_SYS_SPD_BUS_NUM.  The global
- * variable i2c_bus_num must be compile-time initialized to CONFIG_SYS_SPD_BUS_NUM,
- * so that the SPD code will work.  This means that all pre-relocation I2C
- * operations can only occur on the CONFIG_SYS_SPD_BUS_NUM bus.  So if
- * CONFIG_SYS_EEPROM_BUS_NUM != CONFIG_SYS_SPD_BUS_NUM, then we can't read the EEPROM when
- * this function is called.  Oh well.
- */
-unsigned int get_cpu_board_revision(void)
-{
-	struct board_eeprom {
-		u32 id;           /* 0x00 - 0x03 EEPROM Tag 'CCID' */
-		u8 major;         /* 0x04        Board revision, major */
-		u8 minor;         /* 0x05        Board revision, minor */
-	} be;
-
-#ifndef CONFIG_DM_I2C
-	i2c_read(CONFIG_SYS_I2C_EEPROM_ADDR, 0, CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
-		(void *)&be, sizeof(be));
-#else
-	struct udevice *dev;
-#ifdef CONFIG_SYS_EEPROM_BUS_NUM
-	ret = i2c_get_chip_for_busnum(CONFIG_SYS_EEPROM_BUS_NUM,
-				      CONFIG_SYS_I2C_EEPROM_ADDR,
-				      CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
-				      &dev);
-#else
-	ret = i2c_get_chip_for_busnum(0, CONFIG_SYS_I2C_EEPROM_ADDR,
-				      CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
-				      &dev)
-#endif
-	if (!ret)
-		dm_i2c_read(dev, 0, (void *)&be, sizeof(be));
-#endif
-
-	if (be.id != (('C' << 24) | ('C' << 16) | ('I' << 8) | 'D'))
-		return MPC85XX_CPU_BOARD_REV(0, 0);
-
-	if ((be.major == 0xff) && (be.minor == 0xff))
-		return MPC85XX_CPU_BOARD_REV(0, 0);
-
-	return MPC85XX_CPU_BOARD_REV(be.major, be.minor);
-}
-#endif
diff --git a/board/solidrun/common/tcpc.c b/board/solidrun/common/tcpc.c
deleted file mode 100644
index 55fc54336b..0000000000
--- a/board/solidrun/common/tcpc.c
+++ /dev/null
@@ -1,1017 +0,0 @@
-/*
- * Copyright 2017,2019 NXP
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-#include <common.h>
-#include <i2c.h>
-#include <time.h>
-#include "tcpc.h"
-
-#ifdef DEBUG
-#define tcpc_debug_log(port, fmt, args...) tcpc_log(port, fmt, ##args)
-#else
-#define tcpc_debug_log(port, fmt, args...)
-#endif
-
-static int tcpc_log(struct tcpc_port *port, const char *fmt, ...)
-{
-	va_list args;
-	int i;
-
-	va_start(args, fmt);
-	i = vscnprintf(port->log_p, port->log_size, fmt, args);
-	va_end(args);
-
-	port->log_size -= i;
-	port->log_p += i;
-
-	return i;
-}
-
-int tcpc_set_cc_to_source(struct tcpc_port *port)
-{
-	uint8_t valb;
-	int err;
-
-	if (port == NULL)
-		return -EINVAL;
-
-	valb = (TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC1_SHIFT) |
-			(TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC2_SHIFT) |
-			(TCPC_ROLE_CTRL_RP_VAL_DEF <<
-			 TCPC_ROLE_CTRL_RP_VAL_SHIFT) | TCPC_ROLE_CTRL_DRP;
-
-	err = dm_i2c_write(port->i2c_dev, TCPC_ROLE_CTRL, &valb, 1);
-	if (err)
-		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
-	return err;
-}
-
-int tcpc_set_cc_to_sink(struct tcpc_port *port)
-{
-	uint8_t valb;
-	int err;
-
-	if (port == NULL)
-		return -EINVAL;
-
-	valb = (TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC1_SHIFT) |
-			(TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC2_SHIFT) | TCPC_ROLE_CTRL_DRP;
-
-	err = dm_i2c_write(port->i2c_dev, TCPC_ROLE_CTRL, &valb, 1);
-	if (err)
-		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
-	return err;
-}
-
-
-int tcpc_set_plug_orientation(struct tcpc_port *port, enum typec_cc_polarity polarity)
-{
-	uint8_t valb;
-	int err;
-
-	if (port == NULL)
-		return -EINVAL;
-
-	err = dm_i2c_read(port->i2c_dev, TCPC_TCPC_CTRL, &valb, 1);
-	if (err) {
-		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
-		return -EIO;
-	}
-
-	if (polarity == TYPEC_POLARITY_CC2)
-		valb |= TCPC_TCPC_CTRL_ORIENTATION;
-	else
-		valb &= ~TCPC_TCPC_CTRL_ORIENTATION;
-
-	err = dm_i2c_write(port->i2c_dev, TCPC_TCPC_CTRL, &valb, 1);
-	if (err) {
-		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
-		return -EIO;
-	}
-
-	return 0;
-}
-
-int tcpc_get_cc_status(struct tcpc_port *port, enum typec_cc_polarity *polarity, enum typec_cc_state *state)
-{
-
-	uint8_t valb_cc, cc2, cc1;
-	int err;
-
-	if (port == NULL || polarity == NULL || state == NULL)
-		return -EINVAL;
-
-	err = dm_i2c_read(port->i2c_dev, TCPC_CC_STATUS, (uint8_t *)&valb_cc, 1);
-	if (err) {
-		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
-		return -EIO;
-	}
-
-	tcpc_debug_log(port, "cc status 0x%x\n", valb_cc);
-
-	cc2 = (valb_cc >> TCPC_CC_STATUS_CC2_SHIFT) & TCPC_CC_STATUS_CC2_MASK;
-	cc1 = (valb_cc >> TCPC_CC_STATUS_CC1_SHIFT) & TCPC_CC_STATUS_CC1_MASK;
-
-	if (valb_cc & TCPC_CC_STATUS_LOOK4CONN)
-		return -EFAULT;
-
-	*state = TYPEC_STATE_OPEN;
-
-	if (valb_cc & TCPC_CC_STATUS_TERM) {
-		if (cc2) {
-			*polarity = TYPEC_POLARITY_CC2;
-
-			switch (cc2) {
-			case 0x1:
-				*state = TYPEC_STATE_SNK_DEFAULT;
-				tcpc_log(port, "SNK.Default on CC2\n");
-				break;
-			case 0x2:
-				*state = TYPEC_STATE_SNK_POWER15;
-				tcpc_log(port, "SNK.Power1.5 on CC2\n");
-				break;
-			case 0x3:
-				*state = TYPEC_STATE_SNK_POWER30;
-				tcpc_log(port, "SNK.Power3.0 on CC2\n");
-				break;
-			}
-		} else if (cc1) {
-			*polarity = TYPEC_POLARITY_CC1;
-
-			switch (cc1) {
-			case 0x1:
-				*state = TYPEC_STATE_SNK_DEFAULT;
-				tcpc_log(port, "SNK.Default on CC1\n");
-				break;
-			case 0x2:
-				*state = TYPEC_STATE_SNK_POWER15;
-				tcpc_log(port, "SNK.Power1.5 on CC1\n");
-				break;
-			case 0x3:
-				*state = TYPEC_STATE_SNK_POWER30;
-				tcpc_log(port, "SNK.Power3.0 on CC1\n");
-				break;
-			}
-		} else {
-			*state = TYPEC_STATE_OPEN;
-			return -EPERM;
-		}
-
-	} else {
-		if (cc2) {
-			*polarity = TYPEC_POLARITY_CC2;
-
-			switch (cc2) {
-			case 0x1:
-				if (cc1 == 0x1) {
-					*state = TYPEC_STATE_SRC_BOTH_RA;
-					tcpc_log(port, "SRC.Ra on both CC1 and CC2\n");
-				} else if (cc1 == 0x2) {
-					*state = TYPEC_STATE_SRC_RD_RA;
-					tcpc_log(port, "SRC.Ra on CC2, SRC.Rd on CC1\n");
-				} else if (cc1 == 0x0) {
-					tcpc_log(port, "SRC.Ra only on CC2\n");
-					return -EFAULT;
-				} else
-					return -EFAULT;
-				break;
-			case 0x2:
-				if (cc1 == 0x1) {
-					*state = TYPEC_STATE_SRC_RD_RA;
-					tcpc_log(port, "SRC.Ra on CC1, SRC.Rd on CC2\n");
-				} else if (cc1 == 0x0) {
-					*state = TYPEC_STATE_SRC_RD;
-					tcpc_log(port, "SRC.Rd on CC2\n");
-				} else
-					return -EFAULT;
-				break;
-			case 0x3:
-				*state = TYPEC_STATE_SRC_RESERVED;
-				return -EFAULT;
-			}
-		} else if (cc1) {
-			*polarity = TYPEC_POLARITY_CC1;
-
-			switch (cc1) {
-			case 0x1:
-				tcpc_log(port, "SRC.Ra only on CC1\n");
-				return -EFAULT;
-			case 0x2:
-				*state = TYPEC_STATE_SRC_RD;
-				tcpc_log(port, "SRC.Rd on CC1\n");
-				break;
-			case 0x3:
-				*state = TYPEC_STATE_SRC_RESERVED;
-				return -EFAULT;
-			}
-		} else {
-			*state = TYPEC_STATE_OPEN;
-			return -EPERM;
-		}
-	}
-
-	return 0;
-}
-
-int tcpc_clear_alert(struct tcpc_port *port, uint16_t clear_mask)
-{
-	int err;
-
-	if (port == NULL)
-		return -EINVAL;
-
-	err = dm_i2c_write(port->i2c_dev, TCPC_ALERT, (const uint8_t *)&clear_mask, 2);
-	if (err) {
-		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
-		return -EIO;
-	}
-
-	return 0;
-}
-
-int tcpc_send_command(struct tcpc_port *port, uint8_t command)
-{
-	int err;
-
-	if (port == NULL)
-		return -EINVAL;
-
-	err = dm_i2c_write(port->i2c_dev, TCPC_COMMAND, (const uint8_t *)&command, 1);
-	if (err) {
-		tcpc_log(port, "%s dm_i2c_write failed, err %d\n", __func__, err);
-		return -EIO;
-	}
-
-	return 0;
-}
-
-int tcpc_polling_reg(struct tcpc_port *port, uint8_t reg,
-	uint8_t reg_width, uint16_t mask, uint16_t value, ulong timeout_ms)
-{
-	uint16_t val = 0;
-	int err;
-	ulong start;
-
-	if (port == NULL)
-		return -EINVAL;
-
-	tcpc_debug_log(port, "%s reg 0x%x, mask 0x%x, value 0x%x\n", __func__, reg, mask, value);
-
-	/* TCPC registers is 8 bits or 16 bits */
-	if (reg_width != 1 && reg_width != 2)
-		return -EINVAL;
-
-	start = get_timer(0);	/* Get current timestamp */
-	do {
-		err = dm_i2c_read(port->i2c_dev, reg, (uint8_t *)&val, reg_width);
-		if (err)
-			return -EIO;
-
-		if ((val & mask) == value)
-			return 0;
-	} while (get_timer(0) < (start + timeout_ms));
-
-	return -ETIME;
-}
-
-void tcpc_print_log(struct tcpc_port *port)
-{
-	if (port == NULL)
-		return;
-
-	if (port->log_print == port->log_p) /*nothing to output*/
-		return;
-
-	printf("%s", port->log_print);
-
-	port->log_print = port->log_p;
-}
-
-int tcpc_setup_dfp_mode(struct tcpc_port *port)
-{
-	enum typec_cc_polarity pol;
-	enum typec_cc_state state;
-	int ret;
-
-	if ((port == NULL) || (port->i2c_dev == NULL))
-		return -EINVAL;
-
-	if (tcpc_pd_sink_check_charging(port)) {
-		tcpc_log(port, "%s: Can't apply DFP mode when PD is charging\n",
-			__func__);
-		return -EPERM;
-	}
-
-	tcpc_set_cc_to_source(port);
-
-	ret = tcpc_send_command(port, TCPC_CMD_LOOK4CONNECTION);
-	if (ret)
-		return ret;
-
-	/* At least wait tCcStatusDelay + tTCPCFilter + tCcTCPCSampleRate (max) = 200us + 500us + ?ms
-	 * PTN5110 datasheet does not contain the sample rate value, according other productions,
-	 * the sample rate is at ms level, about 2 ms -10ms. So wait 100ms should be enough.
-	 */
-	mdelay(100);
-
-	ret = tcpc_polling_reg(port, TCPC_ALERT, 2, TCPC_ALERT_CC_STATUS, TCPC_ALERT_CC_STATUS, 100);
-	if (ret) {
-		tcpc_log(port, "%s: Polling ALERT register, TCPC_ALERT_CC_STATUS bit failed, ret = %d\n",
-			__func__, ret);
-		return ret;
-	}
-
-	ret = tcpc_get_cc_status(port, &pol, &state);
-	tcpc_clear_alert(port, TCPC_ALERT_CC_STATUS);
-
-	if (!ret) {
-		/* If presenting as Rd/audio mode/open, return */
-		if (state != TYPEC_STATE_SRC_RD_RA && state != TYPEC_STATE_SRC_RD)
-			return -EPERM;
-
-		if (pol == TYPEC_POLARITY_CC1)
-			tcpc_debug_log(port, "polarity cc1\n");
-		else
-			tcpc_debug_log(port, "polarity cc2\n");
-
-		if (port->ss_sel_func)
-			port->ss_sel_func(pol);
-
-		ret = tcpc_set_plug_orientation(port, pol);
-		if (ret)
-			return ret;
-
-		/* Enable source vbus default voltage */
-		ret = tcpc_send_command(port, TCPC_CMD_SRC_VBUS_DEFAULT);
-		if (ret)
-			return ret;
-
-		/* The max vbus on time is 200ms, we add margin 100ms */
-		mdelay(300);
-
-	}
-
-	return 0;
-}
-
-int tcpc_setup_ufp_mode(struct tcpc_port *port)
-{
-	enum typec_cc_polarity pol;
-	enum typec_cc_state state;
-	int ret;
-
-	if ((port == NULL) || (port->i2c_dev == NULL))
-		return -EINVAL;
-
-	/* Check if the PD charge is working. If not, need to configure CC role for UFP */
-	if (!tcpc_pd_sink_check_charging(port)) {
-
-		/* Disable the source vbus once it is enabled by DFP mode */
-		tcpc_disable_src_vbus(port);
-
-		tcpc_set_cc_to_sink(port);
-
-		ret = tcpc_send_command(port, TCPC_CMD_LOOK4CONNECTION);
-		if (ret)
-			return ret;
-
-		/* At least wait tCcStatusDelay + tTCPCFilter + tCcTCPCSampleRate (max) = 200us + 500us + ?ms
-		 * PTN5110 datasheet does not contain the sample rate value, according other productions,
-		 * the sample rate is at ms level, about 2 ms -10ms. So wait 100ms should be enough.
-		 */
-		mdelay(100);
-
-		ret = tcpc_polling_reg(port, TCPC_ALERT, 2, TCPC_ALERT_CC_STATUS, TCPC_ALERT_CC_STATUS, 100);
-		if (ret) {
-			tcpc_log(port, "%s: Polling ALERT register, TCPC_ALERT_CC_STATUS bit failed, ret = %d\n",
-				__func__, ret);
-			return ret;
-		}
-
-		ret = tcpc_get_cc_status(port, &pol, &state);
-		tcpc_clear_alert(port, TCPC_ALERT_CC_STATUS);
-
-	} else {
-		ret = tcpc_get_cc_status(port, &pol, &state);
-	}
-
-	if (!ret) {
-		/* If presenting not as sink, then return */
-		if (state != TYPEC_STATE_SNK_DEFAULT && state != TYPEC_STATE_SNK_POWER15 &&
-			state != TYPEC_STATE_SNK_POWER30)
-			return -EPERM;
-
-		if (pol == TYPEC_POLARITY_CC1)
-			tcpc_debug_log(port, "polarity cc1\n");
-		else
-			tcpc_debug_log(port, "polarity cc2\n");
-
-		if (port->ss_sel_func)
-			port->ss_sel_func(pol);
-
-		ret = tcpc_set_plug_orientation(port, pol);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-int tcpc_disable_src_vbus(struct tcpc_port *port)
-{
-	int ret;
-
-	if (port == NULL)
-		return -EINVAL;
-
-	/* Disable VBUS*/
-	ret = tcpc_send_command(port, TCPC_CMD_DISABLE_SRC_VBUS);
-	if (ret)
-		return ret;
-
-	/* The max vbus off time is 0.5ms, we add margin 0.5 ms */
-	mdelay(1);
-
-	return 0;
-}
-
-int tcpc_disable_sink_vbus(struct tcpc_port *port)
-{
-	int ret;
-
-	if (port == NULL)
-		return -EINVAL;
-
-	/* Disable SINK VBUS*/
-	ret = tcpc_send_command(port, TCPC_CMD_DISABLE_SINK_VBUS);
-	if (ret)
-		return ret;
-
-	/* The max vbus off time is 0.5ms, we add margin 0.5 ms */
-	mdelay(1);
-
-	return 0;
-}
-
-
-static int tcpc_pd_receive_message(struct tcpc_port *port, struct pd_message *msg)
-{
-	int ret;
-	uint8_t cnt;
-	uint16_t val;
-
-	if (port == NULL)
-		return -EINVAL;
-
-	/* Generally the max tSenderResponse is 30ms, max tTypeCSendSourceCap is 200ms, we set the timeout to 500ms */
-	ret = tcpc_polling_reg(port, TCPC_ALERT, 2, TCPC_ALERT_RX_STATUS, TCPC_ALERT_RX_STATUS, 500);
-	if (ret) {
-		tcpc_log(port, "%s: Polling ALERT register, TCPC_ALERT_RX_STATUS bit failed, ret = %d\n",
-			__func__, ret);
-		return ret;
-	}
-
-	cnt = 0;
-	ret = dm_i2c_read(port->i2c_dev, TCPC_RX_BYTE_CNT, (uint8_t *)&cnt, 1);
-	if (ret)
-		return -EIO;
-
-	if (cnt > 0) {
-		ret = dm_i2c_read(port->i2c_dev, TCPC_RX_BUF_FRAME_TYPE, (uint8_t *)msg, cnt);
-		if (ret)
-			return -EIO;
-
-		/* Clear RX status alert bit */
-		val = TCPC_ALERT_RX_STATUS;
-		ret = dm_i2c_write(port->i2c_dev, TCPC_ALERT, (const uint8_t *)&val, 2);
-		if (ret)
-			return -EIO;
-	}
-
-	return cnt;
-}
-
-static int tcpc_pd_transmit_message(struct tcpc_port *port, struct pd_message *msg_p, uint8_t bytes)
-{
-	int ret;
-	uint8_t valb;
-	uint16_t val = 0;
-
-	if (port == NULL)
-		return -EINVAL;
-
-	if (msg_p == NULL || bytes <= 0)
-		return -EINVAL;
-
-	ret = dm_i2c_write(port->i2c_dev, TCPC_TX_BYTE_CNT, (const uint8_t *)&bytes, 1);
-	if (ret)
-		return -EIO;
-
-	ret = dm_i2c_write(port->i2c_dev, TCPC_TX_HDR, (const uint8_t *)&(msg_p->header), bytes);
-	if (ret)
-		return -EIO;
-
-	valb = (3 << TCPC_TRANSMIT_RETRY_SHIFT) | (TCPC_TX_SOP << TCPC_TRANSMIT_TYPE_SHIFT);
-	ret = dm_i2c_write(port->i2c_dev, TCPC_TRANSMIT, (const uint8_t *)&valb, 1);
-	if (ret)
-		return -EIO;
-
-	/* Max tReceive is 1.1ms, we set to 5ms timeout */
-	ret = tcpc_polling_reg(port, TCPC_ALERT, 2, TCPC_ALERT_TX_SUCCESS, TCPC_ALERT_TX_SUCCESS, 5);
-	if (ret) {
-		if (ret == -ETIME) {
-			ret = dm_i2c_read(port->i2c_dev, TCPC_ALERT, (uint8_t *)&val, 2);
-			if (ret)
-				return -EIO;
-
-			if (val & TCPC_ALERT_TX_FAILED)
-				tcpc_log(port, "%s: PD TX FAILED, ALERT = 0x%x\n", __func__, val);
-
-			if (val & TCPC_ALERT_TX_DISCARDED)
-				tcpc_log(port, "%s: PD TX DISCARDED, ALERT = 0x%x\n", __func__, val);
-
-		} else {
-			tcpc_log(port, "%s: Polling ALERT register, TCPC_ALERT_TX_SUCCESS bit failed, ret = %d\n",
-				__func__, ret);
-		}
-	} else {
-		port->tx_msg_id = (port->tx_msg_id + 1) & PD_HEADER_ID_MASK;
-	}
-
-	/* Clear ALERT status */
-	val &= (TCPC_ALERT_TX_FAILED | TCPC_ALERT_TX_DISCARDED | TCPC_ALERT_TX_SUCCESS);
-	ret = dm_i2c_write(port->i2c_dev, TCPC_ALERT, (const uint8_t *)&val, 2);
-	if (ret)
-		return -EIO;
-
-	return ret;
-}
-
-static void tcpc_log_source_caps(struct tcpc_port *port, struct pd_message *msg, unsigned int capcount)
-{
-	int i;
-
-	for (i = 0; i < capcount; i++) {
-		u32 pdo = msg->payload[i];
-		enum pd_pdo_type type = pdo_type(pdo);
-
-		tcpc_log(port, "PDO %d: type %d, ",
-			 i, type);
-
-		switch (type) {
-		case PDO_TYPE_FIXED:
-			tcpc_log(port, "%u mV, %u mA [%s%s%s%s%s%s]\n",
-				  pdo_fixed_voltage(pdo),
-				  pdo_max_current(pdo),
-				  (pdo & PDO_FIXED_DUAL_ROLE) ?
-							"R" : "",
-				  (pdo & PDO_FIXED_SUSPEND) ?
-							"S" : "",
-				  (pdo & PDO_FIXED_HIGHER_CAP) ?
-							"H" : "",
-				  (pdo & PDO_FIXED_USB_COMM) ?
-							"U" : "",
-				  (pdo & PDO_FIXED_DATA_SWAP) ?
-							"D" : "",
-				  (pdo & PDO_FIXED_EXTPOWER) ?
-							"E" : "");
-			break;
-		case PDO_TYPE_VAR:
-			tcpc_log(port, "%u-%u mV, %u mA\n",
-				  pdo_min_voltage(pdo),
-				  pdo_max_voltage(pdo),
-				  pdo_max_current(pdo));
-			break;
-		case PDO_TYPE_BATT:
-			tcpc_log(port, "%u-%u mV, %u mW\n",
-				  pdo_min_voltage(pdo),
-				  pdo_max_voltage(pdo),
-				  pdo_max_power(pdo));
-			break;
-		default:
-			tcpc_log(port, "undefined\n");
-			break;
-		}
-	}
-}
-
-static int tcpc_pd_select_pdo(struct pd_message *msg, uint32_t capcount, uint32_t max_snk_mv, uint32_t max_snk_ma)
-{
-	unsigned int i, max_mw = 0, max_mv = 0;
-	int ret = -EINVAL;
-
-	/*
-	 * Select the source PDO providing the most power while staying within
-	 * the board's voltage limits. Prefer PDO providing exp
-	 */
-	for (i = 0; i < capcount; i++) {
-		u32 pdo = msg->payload[i];
-		enum pd_pdo_type type = pdo_type(pdo);
-		unsigned int mv, ma, mw;
-
-		if (type == PDO_TYPE_FIXED)
-			mv = pdo_fixed_voltage(pdo);
-		else
-			mv = pdo_min_voltage(pdo);
-
-		if (type == PDO_TYPE_BATT) {
-			mw = pdo_max_power(pdo);
-		} else {
-			ma = min(pdo_max_current(pdo),
-				 max_snk_ma);
-			mw = ma * mv / 1000;
-		}
-
-		/* Perfer higher voltages if available */
-		if ((mw > max_mw || (mw == max_mw && mv > max_mv)) &&
-		    mv <= max_snk_mv) {
-			ret = i;
-			max_mw = mw;
-			max_mv = mv;
-		}
-	}
-
-	return ret;
-}
-
-static int tcpc_pd_build_request(struct tcpc_port *port,
-										struct pd_message *msg,
-										uint32_t capcount,
-										uint32_t max_snk_mv,
-										uint32_t max_snk_ma,
-										uint32_t max_snk_mw,
-										uint32_t operating_snk_mw,
-										uint32_t *rdo)
-{
-	unsigned int mv, ma, mw, flags;
-	unsigned int max_ma, max_mw;
-	enum pd_pdo_type type;
-	int index;
-	u32 pdo;
-
-	index = tcpc_pd_select_pdo(msg, capcount, max_snk_mv, max_snk_ma);
-	if (index < 0)
-		return -EINVAL;
-
-	pdo = msg->payload[index];
-	type = pdo_type(pdo);
-
-	if (type == PDO_TYPE_FIXED)
-		mv = pdo_fixed_voltage(pdo);
-	else
-		mv = pdo_min_voltage(pdo);
-
-	/* Select maximum available current within the board's power limit */
-	if (type == PDO_TYPE_BATT) {
-		mw = pdo_max_power(pdo);
-		ma = 1000 * min(mw, max_snk_mw) / mv;
-	} else {
-		ma = min(pdo_max_current(pdo),
-			 1000 * max_snk_mw / mv);
-	}
-	ma = min(ma, max_snk_ma);
-
-	/* XXX: Any other flags need to be set? */
-	flags = 0;
-
-	/* Set mismatch bit if offered power is less than operating power */
-	mw = ma * mv / 1000;
-	max_ma = ma;
-	max_mw = mw;
-	if (mw < operating_snk_mw) {
-		flags |= RDO_CAP_MISMATCH;
-		max_mw = operating_snk_mw;
-		max_ma = max_mw * 1000 / mv;
-	}
-
-	if (type == PDO_TYPE_BATT) {
-		*rdo = RDO_BATT(index + 1, mw, max_mw, flags);
-
-		tcpc_log(port, "Requesting PDO %d: %u mV, %u mW%s\n",
-			 index, mv, mw,
-			 flags & RDO_CAP_MISMATCH ? " [mismatch]" : "");
-	} else {
-		*rdo = RDO_FIXED(index + 1, ma, max_ma, flags);
-
-		tcpc_log(port, "Requesting PDO %d: %u mV, %u mA%s\n",
-			 index, mv, ma,
-			 flags & RDO_CAP_MISMATCH ? " [mismatch]" : "");
-	}
-
-	return 0;
-}
-
-static void tcpc_pd_sink_process(struct tcpc_port *port)
-{
-	int ret;
-	uint8_t msgtype;
-	uint32_t objcnt;
-	struct pd_message msg;
-	enum pd_sink_state pd_state = WAIT_SOURCE_CAP;
-
-	while (tcpc_pd_receive_message(port, &msg) > 0) {
-
-		msgtype = pd_header_type(msg.header);
-		objcnt = pd_header_cnt_le(msg.header);
-
-		tcpc_debug_log(port, "get msg, type %d, cnt %d\n", msgtype, objcnt);
-
-		switch (pd_state) {
-		case WAIT_SOURCE_CAP:
-		case SINK_READY:
-			if (msgtype != PD_DATA_SOURCE_CAP)
-				continue;
-
-			uint32_t rdo = 0;
-
-			tcpc_log_source_caps(port, &msg, objcnt);
-
-			tcpc_pd_build_request(port, &msg, objcnt,
-				port->cfg.max_snk_mv, port->cfg.max_snk_ma,
-				port->cfg.max_snk_mw, port->cfg.op_snk_mv,
-				&rdo);
-
-			memset(&msg, 0, sizeof(msg));
-			msg.header = PD_HEADER(PD_DATA_REQUEST, 0, 0, port->tx_msg_id, 1);  /* power sink, data device, id 0, len 1 */
-			msg.payload[0] = rdo;
-
-			ret = tcpc_pd_transmit_message(port, &msg, 6);
-			if (ret)
-				tcpc_log(port, "send request failed\n");
-			else
-				pd_state = WAIT_SOURCE_ACCEPT;
-
-			break;
-		case WAIT_SOURCE_ACCEPT:
-			if (objcnt > 0) /* Should be ctrl message */
-				continue;
-
-			if (msgtype == PD_CTRL_ACCEPT) {
-				pd_state = WAIT_SOURCE_READY;
-				tcpc_log(port, "Source accept request\n");
-			} else if (msgtype == PD_CTRL_REJECT) {
-				tcpc_log(port, "Source reject request\n");
-				return;
-			}
-
-			break;
-		case WAIT_SOURCE_READY:
-			if (objcnt > 0) /* Should be ctrl message */
-				continue;
-
-			if (msgtype == PD_CTRL_PS_RDY) {
-				tcpc_log(port, "PD source ready!\n");
-				pd_state = SINK_READY;
-			}
-
-			break;
-		default:
-			tcpc_log(port, "unexpect status: %u\n", pd_state);
-			break;
-		}
-	}
-}
-
-bool tcpc_pd_sink_check_charging(struct tcpc_port *port)
-{
-	uint8_t valb;
-	int err;
-	enum typec_cc_polarity pol;
-	enum typec_cc_state state;
-
-	if (port == NULL)
-		return false;
-
-	/* Check the CC status, must be sink */
-	err = tcpc_get_cc_status(port, &pol, &state);
-	if (err || (state != TYPEC_STATE_SNK_POWER15
-		&& state != TYPEC_STATE_SNK_POWER30
-		&& state != TYPEC_STATE_SNK_DEFAULT)) {
-		tcpc_debug_log(port, "TCPC wrong state for PD charging, err = %d, CC = 0x%x\n",
-			err, state);
-		return false;
-	}
-
-	/* Check the VBUS PRES and SINK VBUS for dead battery */
-	err = dm_i2c_read(port->i2c_dev, TCPC_POWER_STATUS, &valb, 1);
-	if (err) {
-		tcpc_debug_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
-		return false;
-	}
-
-	if (!(valb & TCPC_POWER_STATUS_VBUS_PRES)) {
-		tcpc_debug_log(port, "VBUS NOT PRES \n");
-		return false;
-	}
-
-	if (!(valb & TCPC_POWER_STATUS_SINKING_VBUS)) {
-		tcpc_debug_log(port, "SINK VBUS is not enabled for dead battery\n");
-		return false;
-	}
-
-	return true;
-}
-
-static int tcpc_pd_sink_disable(struct tcpc_port *port)
-{
-	uint8_t valb;
-	int err;
-
-	if (port == NULL)
-		return -EINVAL;
-
-	port->pd_state = UNATTACH;
-
-	/* Check the VBUS PRES and SINK VBUS for dead battery */
-	err = dm_i2c_read(port->i2c_dev, TCPC_POWER_STATUS, &valb, 1);
-	if (err) {
-		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
-		return -EIO;
-	}
-
-	if ((valb & TCPC_POWER_STATUS_VBUS_PRES) && (valb & TCPC_POWER_STATUS_SINKING_VBUS)) {
-		dm_i2c_read(port->i2c_dev, TCPC_POWER_CTRL, (uint8_t *)&valb, 1);
-		valb &= ~TCPC_POWER_CTRL_AUTO_DISCH_DISCO; /* disable AutoDischargeDisconnect */
-		dm_i2c_write(port->i2c_dev, TCPC_POWER_CTRL, (const uint8_t *)&valb, 1);
-
-		tcpc_disable_sink_vbus(port);
-	}
-
-	if (port->cfg.switch_setup_func)
-		port->cfg.switch_setup_func(port);
-
-	return 0;
-}
-
-static int tcpc_pd_sink_init(struct tcpc_port *port)
-{
-	uint8_t valb;
-	uint16_t val;
-	int err;
-	enum typec_cc_polarity pol;
-	enum typec_cc_state state;
-
-	if (port == NULL)
-		return -EINVAL;
-
-	port->pd_state = UNATTACH;
-
-	/* Check the VBUS PRES and SINK VBUS for dead battery */
-	err = dm_i2c_read(port->i2c_dev, TCPC_POWER_STATUS, &valb, 1);
-	if (err) {
-		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
-		return -EIO;
-	}
-
-	if (!(valb & TCPC_POWER_STATUS_VBUS_PRES)) {
-		tcpc_debug_log(port, "VBUS NOT PRES \n");
-		return -EPERM;
-	}
-
-	if (!(valb & TCPC_POWER_STATUS_SINKING_VBUS)) {
-		tcpc_debug_log(port, "SINK VBUS is not enabled for dead battery\n");
-		return -EPERM;
-	}
-
-	err = dm_i2c_read(port->i2c_dev, TCPC_ALERT, (uint8_t *)&val, 2);
-	if (err) {
-		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
-		return -EIO;
-	}
-
-	if (!(val & TCPC_ALERT_CC_STATUS)) {
-		tcpc_debug_log(port, "CC STATUS not detected for dead battery\n");
-		return -EPERM;
-	}
-
-	err = tcpc_get_cc_status(port, &pol, &state);
-	if (err || (state != TYPEC_STATE_SNK_POWER15
-		&& state != TYPEC_STATE_SNK_POWER30
-		&& state != TYPEC_STATE_SNK_DEFAULT)) {
-		tcpc_log(port, "TCPC wrong state for dead battery, err = %d, CC = 0x%x\n",
-			err, state);
-		return -EPERM;
-	} else {
-		err = tcpc_set_plug_orientation(port, pol);
-		if (err) {
-			tcpc_log(port, "TCPC set plug orientation failed, err = %d\n", err);
-			return err;
-		}
-		port->pd_state = ATTACHED;
-	}
-
-	dm_i2c_read(port->i2c_dev, TCPC_POWER_CTRL, (uint8_t *)&valb, 1);
-	valb &= ~TCPC_POWER_CTRL_AUTO_DISCH_DISCO; /* disable AutoDischargeDisconnect */
-	dm_i2c_write(port->i2c_dev, TCPC_POWER_CTRL, (const uint8_t *)&valb, 1);
-
-	if (port->cfg.switch_setup_func)
-		port->cfg.switch_setup_func(port);
-
-	/* As sink role */
-	valb = 0x00;
-	err = dm_i2c_write(port->i2c_dev, TCPC_MSG_HDR_INFO, (const uint8_t *)&valb, 1);
-	if (err) {
-		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
-		return -EIO;
-	}
-
-	/* Enable rx */
-	valb = TCPC_RX_DETECT_SOP | TCPC_RX_DETECT_HARD_RESET;
-	err = dm_i2c_write(port->i2c_dev, TCPC_RX_DETECT, (const uint8_t *)&valb, 1);
-	if (err) {
-		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, err);
-		return -EIO;
-	}
-
-	tcpc_pd_sink_process(port);
-
-	return 0;
-}
-
-int tcpc_init(struct tcpc_port *port, struct tcpc_port_config config, ss_mux_sel ss_sel_func)
-{
-	int ret;
-	uint8_t valb;
-	uint16_t vid, pid;
-	struct udevice *bus;
-	struct udevice *i2c_dev = NULL;
-
-	memset(port, 0, sizeof(struct tcpc_port));
-
-	if (port == NULL)
-		return -EINVAL;
-
-	port->cfg = config;
-	port->tx_msg_id = 0;
-	port->ss_sel_func = ss_sel_func;
-	port->log_p = (char *)&(port->logbuffer);
-	port->log_size = TCPC_LOG_BUFFER_SIZE;
-	port->log_print = port->log_p;
-	memset(&(port->logbuffer), 0, TCPC_LOG_BUFFER_SIZE);
-
-	ret = uclass_get_device_by_seq(UCLASS_I2C, port->cfg.i2c_bus, &bus);
-	if (ret) {
-		printf("%s: Can't find bus\n", __func__);
-		return -EINVAL;
-	}
-
-	ret = dm_i2c_probe(bus, port->cfg.addr, 0, &i2c_dev);
-	if (ret) {
-		printf("%s: Can't find device id=0x%x\n",
-			__func__, config.addr);
-		return -ENODEV;
-	}
-
-	port->i2c_dev = i2c_dev;
-
-	/* Check the Initialization Status bit in 1s */
-	ret = tcpc_polling_reg(port, TCPC_POWER_STATUS, 1, TCPC_POWER_STATUS_UNINIT, 0, 1000);
-	if (ret) {
-		tcpc_log(port, "%s: Polling TCPC POWER STATUS Initialization Status bit failed, ret = %d\n",
-			__func__, ret);
-		return ret;
-	}
-
-	dm_i2c_read(port->i2c_dev, TCPC_POWER_STATUS, &valb, 1);
-	tcpc_debug_log(port, "POWER STATUS: 0x%x\n", valb);
-
-	/* Clear AllRegistersResetToDefault */
-	valb = 0x80;
-	ret = dm_i2c_write(port->i2c_dev, TCPC_FAULT_STATUS, (const uint8_t *)&valb, 1);
-	if (ret) {
-		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, ret);
-		return -EIO;
-	}
-
-	/* Read Vendor ID and Product ID */
-	ret = dm_i2c_read(port->i2c_dev, TCPC_VENDOR_ID, (uint8_t *)&vid, 2);
-	if (ret) {
-		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, ret);
-		return -EIO;
-	}
-
-	ret = dm_i2c_read(port->i2c_dev, TCPC_PRODUCT_ID, (uint8_t *)&pid, 2);
-	if (ret) {
-		tcpc_log(port, "%s dm_i2c_read failed, err %d\n", __func__, ret);
-		return -EIO;
-	}
-
-	tcpc_log(port, "TCPC:  Vendor ID [0x%x], Product ID [0x%x], Addr [I2C%u 0x%x]\n",
-		vid, pid, port->cfg.i2c_bus, port->cfg.addr);
-
-	if (!port->cfg.disable_pd) {
-		if  (port->cfg.port_type == TYPEC_PORT_UFP
-			|| port->cfg.port_type == TYPEC_PORT_DRP)
-			tcpc_pd_sink_init(port);
-	} else {
-		tcpc_pd_sink_disable(port);
-	}
-
-	tcpc_clear_alert(port, 0xffff);
-
-	tcpc_print_log(port);
-
-	return 0;
-}
diff --git a/board/solidrun/common/tcpc.h b/board/solidrun/common/tcpc.h
deleted file mode 100644
index ff749518a8..0000000000
--- a/board/solidrun/common/tcpc.h
+++ /dev/null
@@ -1,469 +0,0 @@
-/*
- * Copyright 2017 NXP
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __TCPCI_H
-#define __TCPCI_H
-
-#include <dm.h>
-
-#define TCPC_VENDOR_ID			0x0
-#define TCPC_PRODUCT_ID			0x2
-
-#define TCPC_ALERT					0x10
-#define TCPC_ALERT_VBUS_DISCNCT		BIT(11)
-#define TCPC_ALERT_RX_BUF_OVF		BIT(10)
-#define TCPC_ALERT_FAULT			BIT(9)
-#define TCPC_ALERT_V_ALARM_LO		BIT(8)
-#define TCPC_ALERT_V_ALARM_HI		BIT(7)
-#define TCPC_ALERT_TX_SUCCESS		BIT(6)
-#define TCPC_ALERT_TX_DISCARDED		BIT(5)
-#define TCPC_ALERT_TX_FAILED		BIT(4)
-#define TCPC_ALERT_RX_HARD_RST		BIT(3)
-#define TCPC_ALERT_RX_STATUS		BIT(2)
-#define TCPC_ALERT_POWER_STATUS		BIT(1)
-#define TCPC_ALERT_CC_STATUS		BIT(0)
-
-#define TCPC_TCPC_CTRL				0x19
-#define TCPC_TCPC_CTRL_BIST_MODE	BIT(1)
-#define TCPC_TCPC_CTRL_ORIENTATION	BIT(0)
-
-#define TCPC_ROLE_CTRL				0x1a
-#define TCPC_ROLE_CTRL_DRP			BIT(6)
-#define TCPC_ROLE_CTRL_RP_VAL_SHIFT	4
-#define TCPC_ROLE_CTRL_RP_VAL_MASK	0x3
-#define TCPC_ROLE_CTRL_RP_VAL_DEF	0x0
-#define TCPC_ROLE_CTRL_RP_VAL_1_5	0x1
-#define TCPC_ROLE_CTRL_RP_VAL_3_0	0x2
-#define TCPC_ROLE_CTRL_CC2_SHIFT	2
-#define TCPC_ROLE_CTRL_CC2_MASK		0x3
-#define TCPC_ROLE_CTRL_CC1_SHIFT	0
-#define TCPC_ROLE_CTRL_CC1_MASK		0x3
-#define TCPC_ROLE_CTRL_CC_RA		0x0
-#define TCPC_ROLE_CTRL_CC_RP		0x1
-#define TCPC_ROLE_CTRL_CC_RD		0x2
-#define TCPC_ROLE_CTRL_CC_OPEN		0x3
-
-#define TCPC_POWER_CTRL						0x1c
-#define TCPC_POWER_CTRL_EN_VCONN			BIT(0)
-#define TCPC_POWER_CTRL_VCONN_POWER			BIT(1)
-#define TCPC_POWER_CTRL_FORCE_DISCH			BIT(2)
-#define TCPC_POWER_CTRL_EN_BLEED_CH			BIT(3)
-#define TCPC_POWER_CTRL_AUTO_DISCH_DISCO	BIT(4)
-#define TCPC_POWER_CTRL_DIS_V_ALARMS		BIT(5)
-#define TCPC_POWER_CTRL_VBUS_V_MONITOR		BIT(6)
-
-#define TCPC_CC_STATUS					0x1d
-#define TCPC_CC_STATUS_LOOK4CONN		BIT(5)
-#define TCPC_CC_STATUS_TERM				BIT(4)
-#define TCPC_CC_STATUS_CC2_SHIFT		2
-#define TCPC_CC_STATUS_CC2_MASK			0x3
-#define TCPC_CC_STATUS_CC1_SHIFT		0
-#define TCPC_CC_STATUS_CC1_MASK			0x3
-
-#define TCPC_POWER_STATUS				0x1e
-#define TCPC_POWER_STATUS_UNINIT		BIT(6)
-#define TCPC_POWER_STATUS_VBUS_DET		BIT(3)
-#define TCPC_POWER_STATUS_VBUS_PRES		BIT(2)
-#define TCPC_POWER_STATUS_SINKING_VBUS	BIT(0)
-
-#define TCPC_FAULT_STATUS               0x1f
-
-#define TCPC_COMMAND					0x23
-#define TCPC_CMD_WAKE_I2C				0x11
-#define TCPC_CMD_DISABLE_VBUS_DETECT	0x22
-#define TCPC_CMD_ENABLE_VBUS_DETECT		0x33
-#define TCPC_CMD_DISABLE_SINK_VBUS		0x44
-#define TCPC_CMD_SINK_VBUS				0x55
-#define TCPC_CMD_DISABLE_SRC_VBUS		0x66
-#define TCPC_CMD_SRC_VBUS_DEFAULT		0x77
-#define TCPC_CMD_SRC_VBUS_HIGH			0x88
-#define TCPC_CMD_LOOK4CONNECTION		0x99
-#define TCPC_CMD_RXONEMORE				0xAA
-#define TCPC_CMD_I2C_IDLE				0xFF
-
-#define TCPC_DEV_CAP_1					0x24
-#define TCPC_DEV_CAP_2					0x26
-#define TCPC_STD_INPUT_CAP				0x28
-#define TCPC_STD_OUTPUT_CAP				0x29
-
-#define TCPC_MSG_HDR_INFO				0x2e
-#define TCPC_MSG_HDR_INFO_DATA_ROLE		BIT(3)
-#define TCPC_MSG_HDR_INFO_PWR_ROLE		BIT(0)
-#define TCPC_MSG_HDR_INFO_REV_SHIFT		1
-#define TCPC_MSG_HDR_INFO_REV_MASK		0x3
-
-#define TCPC_RX_DETECT					0x2f
-#define TCPC_RX_DETECT_HARD_RESET		BIT(5)
-#define TCPC_RX_DETECT_SOP				BIT(0)
-
-#define TCPC_RX_BYTE_CNT				0x30
-#define TCPC_RX_BUF_FRAME_TYPE			0x31
-#define TCPC_RX_HDR						0x32
-#define TCPC_RX_DATA					0x34 /* through 0x4f */
-
-#define TCPC_TRANSMIT					0x50
-#define TCPC_TRANSMIT_RETRY_SHIFT		4
-#define TCPC_TRANSMIT_RETRY_MASK		0x3
-#define TCPC_TRANSMIT_TYPE_SHIFT		0
-#define TCPC_TRANSMIT_TYPE_MASK			0x7
-
-#define TCPC_TX_BYTE_CNT				0x51
-#define TCPC_TX_HDR						0x52
-#define TCPC_TX_DATA					0x54 /* through 0x6f */
-
-#define TCPC_VBUS_VOLTAGE					0x70
-#define TCPC_VBUS_VOL_MASK					0x3ff
-#define TCPC_VBUS_VOL_SCALE_FACTOR_MASK		0xc00
-#define TCPC_VBUS_VOL_SCALE_FACTOR_SHIFT	10
-#define TCPC_VBUS_VOL_MV_UNIT				25
-
-#define TCPC_VBUS_SINK_DISCONNECT_THRESH	0x72
-#define TCPC_VBUS_STOP_DISCHARGE_THRESH		0x74
-#define TCPC_VBUS_VOLTAGE_ALARM_HI_CFG		0x76
-#define TCPC_VBUS_VOLTAGE_ALARM_LO_CFG		0x78
-
-enum typec_role {
-	TYPEC_SINK,
-	TYPEC_SOURCE,
-	TYPEC_ROLE_UNKNOWN,
-};
-
-enum typec_data_role {
-	TYPEC_DEVICE,
-	TYPEC_HOST,
-};
-
-enum typec_cc_polarity {
-	TYPEC_POLARITY_CC1,
-	TYPEC_POLARITY_CC2,
-};
-
-enum typec_cc_state {
-	TYPEC_STATE_OPEN,
-	TYPEC_STATE_SRC_BOTH_RA,
-	TYPEC_STATE_SRC_RD_RA,
-	TYPEC_STATE_SRC_RD,
-	TYPEC_STATE_SRC_RESERVED,
-	TYPEC_STATE_SNK_DEFAULT,
-	TYPEC_STATE_SNK_POWER15,
-	TYPEC_STATE_SNK_POWER30,
-};
-
-
-/* USB PD Messages */
-enum pd_ctrl_msg_type {
-	/* 0 Reserved */
-	PD_CTRL_GOOD_CRC = 1,
-	PD_CTRL_GOTO_MIN = 2,
-	PD_CTRL_ACCEPT = 3,
-	PD_CTRL_REJECT = 4,
-	PD_CTRL_PING = 5,
-	PD_CTRL_PS_RDY = 6,
-	PD_CTRL_GET_SOURCE_CAP = 7,
-	PD_CTRL_GET_SINK_CAP = 8,
-	PD_CTRL_DR_SWAP = 9,
-	PD_CTRL_PR_SWAP = 10,
-	PD_CTRL_VCONN_SWAP = 11,
-	PD_CTRL_WAIT = 12,
-	PD_CTRL_SOFT_RESET = 13,
-	/* 14-15 Reserved */
-};
-
-enum pd_data_msg_type {
-	/* 0 Reserved */
-	PD_DATA_SOURCE_CAP = 1,
-	PD_DATA_REQUEST = 2,
-	PD_DATA_BIST = 3,
-	PD_DATA_SINK_CAP = 4,
-	/* 5-14 Reserved */
-	PD_DATA_VENDOR_DEF = 15,
-};
-
-enum tcpc_transmit_type {
-	TCPC_TX_SOP = 0,
-	TCPC_TX_SOP_PRIME = 1,
-	TCPC_TX_SOP_PRIME_PRIME = 2,
-	TCPC_TX_SOP_DEBUG_PRIME = 3,
-	TCPC_TX_SOP_DEBUG_PRIME_PRIME = 4,
-	TCPC_TX_HARD_RESET = 5,
-	TCPC_TX_CABLE_RESET = 6,
-	TCPC_TX_BIST_MODE_2 = 7
-};
-
-enum pd_sink_state{
-	UNATTACH = 0,
-	ATTACHED,
-	WAIT_SOURCE_CAP,
-	WAIT_SOURCE_ACCEPT,
-	WAIT_SOURCE_READY,
-	SINK_READY,
-};
-
-
-#define PD_REV10        0x0
-#define PD_REV20        0x1
-
-#define PD_HEADER_CNT_SHIFT     12
-#define PD_HEADER_CNT_MASK      0x7
-#define PD_HEADER_ID_SHIFT      9
-#define PD_HEADER_ID_MASK       0x7
-#define PD_HEADER_PWR_ROLE      BIT(8)
-#define PD_HEADER_REV_SHIFT     6
-#define PD_HEADER_REV_MASK      0x3
-#define PD_HEADER_DATA_ROLE     BIT(5)
-#define PD_HEADER_TYPE_SHIFT    0
-#define PD_HEADER_TYPE_MASK     0xf
-
-#define PD_HEADER(type, pwr, data, id, cnt)                             \
-	((((type) & PD_HEADER_TYPE_MASK) << PD_HEADER_TYPE_SHIFT) |     \
-	 ((pwr) == TYPEC_SOURCE ? PD_HEADER_PWR_ROLE : 0) |             \
-	 ((data) == TYPEC_HOST ? PD_HEADER_DATA_ROLE : 0) |             \
-	 (PD_REV20 << PD_HEADER_REV_SHIFT) |                            \
-	 (((id) & PD_HEADER_ID_MASK) << PD_HEADER_ID_SHIFT) |           \
-	 (((cnt) & PD_HEADER_CNT_MASK) << PD_HEADER_CNT_SHIFT))
-
-
-static inline unsigned int pd_header_cnt(uint16_t header)
-{
-	return (header >> PD_HEADER_CNT_SHIFT) & PD_HEADER_CNT_MASK;
-}
-
-static inline unsigned int pd_header_cnt_le(__le16 header)
-{
-	return pd_header_cnt(le16_to_cpu(header));
-}
-
-static inline unsigned int pd_header_type(uint16_t header)
-{
-	return (header >> PD_HEADER_TYPE_SHIFT) & PD_HEADER_TYPE_MASK;
-}
-
-static inline unsigned int pd_header_type_le(__le16 header)
-{
-	return pd_header_type(le16_to_cpu(header));
-}
-
-#define PD_MAX_PAYLOAD          7
-
-struct pd_message {
-	uint8_t   frametype;
-	uint16_t  header;
-	uint32_t  payload[PD_MAX_PAYLOAD];
-} __packed;
-
-enum pd_pdo_type {
-	PDO_TYPE_FIXED = 0,
-	PDO_TYPE_BATT = 1,
-	PDO_TYPE_VAR = 2,
-};
-
-
-#define PDO_TYPE_SHIFT          30
-#define PDO_TYPE_MASK           0x3
-
-#define PDO_TYPE(t)     ((t) << PDO_TYPE_SHIFT)
-
-#define PDO_VOLT_MASK           0x3ff
-#define PDO_CURR_MASK           0x3ff
-#define PDO_PWR_MASK            0x3ff
-
-#define PDO_FIXED_DUAL_ROLE     BIT(29) /* Power role swap supported */
-#define PDO_FIXED_SUSPEND       BIT(28) /* USB Suspend supported (Source) */
-#define PDO_FIXED_HIGHER_CAP    BIT(28) /* Requires more than vSafe5V (Sink) */
-#define PDO_FIXED_EXTPOWER      BIT(27) /* Externally powered */
-#define PDO_FIXED_USB_COMM      BIT(26) /* USB communications capable */
-#define PDO_FIXED_DATA_SWAP     BIT(25) /* Data role swap supported */
-#define PDO_FIXED_VOLT_SHIFT    10      /* 50mV units */
-#define PDO_FIXED_CURR_SHIFT    0       /* 10mA units */
-
-#define PDO_FIXED_VOLT(mv)      ((((mv) / 50) & PDO_VOLT_MASK) << PDO_FIXED_VOLT_SHIFT)
-#define PDO_FIXED_CURR(ma)      ((((ma) / 10) & PDO_CURR_MASK) << PDO_FIXED_CURR_SHIFT)
-
-#define PDO_FIXED(mv, ma, flags)                        \
-	(PDO_TYPE(PDO_TYPE_FIXED) | (flags) |           \
-	 PDO_FIXED_VOLT(mv) | PDO_FIXED_CURR(ma))
-
-#define PDO_BATT_MAX_VOLT_SHIFT 20      /* 50mV units */
-#define PDO_BATT_MIN_VOLT_SHIFT 10      /* 50mV units */
-#define PDO_BATT_MAX_PWR_SHIFT  0       /* 250mW units */
-
-#define PDO_BATT_MIN_VOLT(mv) ((((mv) / 50) & PDO_VOLT_MASK) << PDO_BATT_MIN_VOLT_SHIFT)
-#define PDO_BATT_MAX_VOLT(mv) ((((mv) / 50) & PDO_VOLT_MASK) << PDO_BATT_MAX_VOLT_SHIFT)
-#define PDO_BATT_MAX_POWER(mw) ((((mw) / 250) & PDO_PWR_MASK) << PDO_BATT_MAX_PWR_SHIFT)
-
-#define PDO_BATT(min_mv, max_mv, max_mw)                        \
-	(PDO_TYPE(PDO_TYPE_BATT) | PDO_BATT_MIN_VOLT(min_mv) |  \
-	 PDO_BATT_MAX_VOLT(max_mv) | PDO_BATT_MAX_POWER(max_mw))
-
-#define PDO_VAR_MAX_VOLT_SHIFT  20      /* 50mV units */
-#define PDO_VAR_MIN_VOLT_SHIFT  10      /* 50mV units */
-#define PDO_VAR_MAX_CURR_SHIFT  0       /* 10mA units */
-
-#define PDO_VAR_MIN_VOLT(mv) ((((mv) / 50) & PDO_VOLT_MASK) << PDO_VAR_MIN_VOLT_SHIFT)
-#define PDO_VAR_MAX_VOLT(mv) ((((mv) / 50) & PDO_VOLT_MASK) << PDO_VAR_MAX_VOLT_SHIFT)
-#define PDO_VAR_MAX_CURR(ma) ((((ma) / 10) & PDO_CURR_MASK) << PDO_VAR_MAX_CURR_SHIFT)
-
-#define PDO_VAR(min_mv, max_mv, max_ma)                         \
-	(PDO_TYPE(PDO_TYPE_VAR) | PDO_VAR_MIN_VOLT(min_mv) |    \
-	 PDO_VAR_MAX_VOLT(max_mv) | PDO_VAR_MAX_CURR(max_ma))
-
-static inline enum pd_pdo_type pdo_type(uint32_t pdo)
-{
-	return (pdo >> PDO_TYPE_SHIFT) & PDO_TYPE_MASK;
-}
-
-static inline unsigned int pdo_fixed_voltage(uint32_t pdo)
-{
-	return ((pdo >> PDO_FIXED_VOLT_SHIFT) & PDO_VOLT_MASK) * 50;
-}
-
-static inline unsigned int pdo_min_voltage(uint32_t pdo)
-{
-	return ((pdo >> PDO_VAR_MIN_VOLT_SHIFT) & PDO_VOLT_MASK) * 50;
-}
-
-static inline unsigned int pdo_max_voltage(uint32_t pdo)
-{
-	return ((pdo >> PDO_VAR_MAX_VOLT_SHIFT) & PDO_VOLT_MASK) * 50;
-}
-
-static inline unsigned int pdo_max_current(uint32_t pdo)
-{
-	return ((pdo >> PDO_VAR_MAX_CURR_SHIFT) & PDO_CURR_MASK) * 10;
-}
-
-static inline unsigned int pdo_max_power(uint32_t pdo)
-{
-	return ((pdo >> PDO_BATT_MAX_PWR_SHIFT) & PDO_PWR_MASK) * 250;
-}
-
-/* RDO: Request Data Object */
-#define RDO_OBJ_POS_SHIFT       28
-#define RDO_OBJ_POS_MASK        0x7
-#define RDO_GIVE_BACK           BIT(27) /* Supports reduced operating current */
-#define RDO_CAP_MISMATCH        BIT(26) /* Not satisfied by source caps */
-#define RDO_USB_COMM            BIT(25) /* USB communications capable */
-#define RDO_NO_SUSPEND          BIT(24) /* USB Suspend not supported */
-
-#define RDO_PWR_MASK                    0x3ff
-#define RDO_CURR_MASK                   0x3ff
-
-#define RDO_FIXED_OP_CURR_SHIFT         10
-#define RDO_FIXED_MAX_CURR_SHIFT        0
-
-#define RDO_OBJ(idx) (((idx) & RDO_OBJ_POS_MASK) << RDO_OBJ_POS_SHIFT)
-
-#define PDO_FIXED_OP_CURR(ma) ((((ma) / 10) & RDO_CURR_MASK) << RDO_FIXED_OP_CURR_SHIFT)
-#define PDO_FIXED_MAX_CURR(ma) ((((ma) / 10) & RDO_CURR_MASK) << RDO_FIXED_MAX_CURR_SHIFT)
-
-#define RDO_FIXED(idx, op_ma, max_ma, flags)                    \
-	(RDO_OBJ(idx) | (flags) |                               \
-	 PDO_FIXED_OP_CURR(op_ma) | PDO_FIXED_MAX_CURR(max_ma))
-
-#define RDO_BATT_OP_PWR_SHIFT           10      /* 250mW units */
-#define RDO_BATT_MAX_PWR_SHIFT          0       /* 250mW units */
-
-#define RDO_BATT_OP_PWR(mw) ((((mw) / 250) & RDO_PWR_MASK) << RDO_BATT_OP_PWR_SHIFT)
-#define RDO_BATT_MAX_PWR(mw) ((((mw) / 250) & RDO_PWR_MASK) << RDO_BATT_MAX_PWR_SHIFT)
-
-#define RDO_BATT(idx, op_mw, max_mw, flags)                     \
-	(RDO_OBJ(idx) | (flags) |                               \
-	 RDO_BATT_OP_PWR(op_mw) | RDO_BATT_MAX_PWR(max_mw))
-
-static inline unsigned int rdo_index(u32 rdo)
-{
-	return (rdo >> RDO_OBJ_POS_SHIFT) & RDO_OBJ_POS_MASK;
-}
-
-static inline unsigned int rdo_op_current(u32 rdo)
-{
-	return ((rdo >> RDO_FIXED_OP_CURR_SHIFT) & RDO_CURR_MASK) * 10;
-}
-
-static inline unsigned int rdo_max_current(u32 rdo)
-{
-	return ((rdo >> RDO_FIXED_MAX_CURR_SHIFT) &
-			RDO_CURR_MASK) * 10;
-}
-
-static inline unsigned int rdo_op_power(u32 rdo)
-{
-	return ((rdo >> RDO_BATT_OP_PWR_SHIFT) & RDO_PWR_MASK) * 250;
-}
-
-static inline unsigned int rdo_max_power(u32 rdo)
-{
-	return ((rdo >> RDO_BATT_MAX_PWR_SHIFT) & RDO_PWR_MASK) * 250;
-}
-
-#define TCPC_LOG_BUFFER_SIZE 1024
-
-struct tcpc_port;
-
-typedef void (*ss_mux_sel)(enum typec_cc_polarity pol);
-typedef int (*ext_pd_switch_setup)(struct tcpc_port *port_p);
-
-enum tcpc_port_type {
-	TYPEC_PORT_DFP,
-	TYPEC_PORT_UFP,
-	TYPEC_PORT_DRP,
-};
-
-struct tcpc_port_config {
-	uint8_t i2c_bus;
-	uint8_t addr;
-	enum tcpc_port_type port_type;
-	uint32_t max_snk_mv;
-	uint32_t max_snk_ma;
-	uint32_t max_snk_mw;
-	uint32_t op_snk_mv;
-	bool disable_pd;
-	ext_pd_switch_setup switch_setup_func;
-};
-
-struct tcpc_port {
-	struct tcpc_port_config cfg;
-	struct udevice *i2c_dev;
-	ss_mux_sel ss_sel_func;
-	enum pd_sink_state pd_state;
-	uint32_t tx_msg_id;
-	uint32_t log_size;
-	char logbuffer[TCPC_LOG_BUFFER_SIZE];
-	char *log_p;
-	char *log_print;
-};
-
-int tcpc_set_cc_to_source(struct tcpc_port *port);
-int tcpc_set_cc_to_sink(struct tcpc_port *port);
-int tcpc_set_plug_orientation(struct tcpc_port *port, enum typec_cc_polarity polarity);
-int tcpc_get_cc_status(struct tcpc_port *port, enum typec_cc_polarity *polarity, enum typec_cc_state *state);
-int tcpc_clear_alert(struct tcpc_port *port, uint16_t clear_mask);
-int tcpc_send_command(struct tcpc_port *port, uint8_t command);
-int tcpc_polling_reg(struct tcpc_port *port, uint8_t reg,
-	uint8_t reg_width, uint16_t mask, uint16_t value, ulong timeout_ms);
-int tcpc_setup_dfp_mode(struct tcpc_port *port);
-int tcpc_setup_ufp_mode(struct tcpc_port *port);
-int tcpc_disable_src_vbus(struct tcpc_port *port);
-int tcpc_init(struct tcpc_port *port, struct tcpc_port_config config, ss_mux_sel ss_sel_func);
-bool tcpc_pd_sink_check_charging(struct tcpc_port *port);
-void tcpc_print_log(struct tcpc_port *port);
-
-#ifdef CONFIG_SPL_BUILD
-int tcpc_setup_ufp_mode(struct tcpc_port *port)
-{
-	return 0;
-}
-int tcpc_setup_dfp_mode(struct tcpc_port *port)
-{
-	return 0;
-}
-
-int tcpc_disable_src_vbus(struct tcpc_port *port)
-{
-	return 0;
-}
-#endif
-#endif /* __TCPCI_H */
diff --git a/board/solidrun/common/tlv_data.c b/board/solidrun/common/tlv_data.c
deleted file mode 100644
index f08ac8975a..0000000000
--- a/board/solidrun/common/tlv_data.c
+++ /dev/null
@@ -1,102 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright 2020 SolidRun
- */
-
-#include <common.h>
-#include <tlv_eeprom.h>
-#include "tlv_data.h"
-
-#define SR_TLV_CODE_RAM_SIZE	0x81
-
-static void store_product_name(struct tlvinfo_tlv *tlv_entry,
-			       struct tlv_data *td)
-{
-	int len;
-	char *dest;
-
-	if (strlen(td->tlv_product_name[0]) == 0)
-		dest = td->tlv_product_name[0];
-	else if (strlen(td->tlv_product_name[1]) == 0)
-		dest = td->tlv_product_name[1];
-	else
-		return;
-
-	len = min_t(unsigned int, tlv_entry->length,
-		    sizeof(td->tlv_product_name[0]) - 1);
-	memcpy(dest, tlv_entry->value, len);
-}
-
-static void parse_tlv_vendor_ext(struct tlvinfo_tlv *tlv_entry,
-				 struct tlv_data *td)
-{
-	u8 *val = tlv_entry->value;
-	u32 pen; /* IANA Private Enterprise Numbers */
-
-	if (tlv_entry->length < 5) /* 4 bytes PEN + at least 1 byte type */
-		return;
-
-	/* PEN is big endian */
-	pen = (val[0] << 24) | (val[1] << 16) | (val[2] << 8) | val[3];
-	/* Not a real PEN */
-	if (pen != 0xffffffff)
-		return;
-
-	if (val[4] != SR_TLV_CODE_RAM_SIZE)
-		return;
-	if (tlv_entry->length != 6)
-		return;
-	td->ram_size = val[5];
-}
-
-static void parse_tlv_data(u8 *eeprom, struct tlvinfo_header *hdr,
-			   struct tlvinfo_tlv *entry, struct tlv_data *td)
-{
-	unsigned int tlv_offset, tlv_len;
-
-	tlv_offset = sizeof(struct tlvinfo_header);
-	tlv_len = sizeof(struct tlvinfo_header) + be16_to_cpu(hdr->totallen);
-	while (tlv_offset < tlv_len) {
-		entry = (struct tlvinfo_tlv *)&eeprom[tlv_offset];
-
-		switch (entry->type) {
-		case TLV_CODE_PRODUCT_NAME:
-			store_product_name(entry, td);
-			break;
-		case TLV_CODE_VENDOR_EXT:
-			parse_tlv_vendor_ext(entry, td);
-			break;
-		default:
-			break;
-		}
-
-		tlv_offset += sizeof(struct tlvinfo_tlv) + entry->length;
-	}
-}
-
-void read_tlv_data(struct tlv_data *td)
-{
-	u8 eeprom_data[TLV_TOTAL_LEN_MAX];
-	struct tlvinfo_header *tlv_hdr;
-	struct tlvinfo_tlv *tlv_entry;
-	int ret, i;
-
-	for (i = 0; i < 2; i++) {
-		ret = read_tlvinfo_tlv_eeprom(eeprom_data, &tlv_hdr,
-					      &tlv_entry, i);
-		if (ret < 0)
-			continue;
-		parse_tlv_data(eeprom_data, tlv_hdr, tlv_entry, td);
-	}
-}
-
-bool sr_product_is(const struct tlv_data *td, const char *product)
-{
-	/* Allow prefix sub-string match */
-	if (strncmp(td->tlv_product_name[0], product, strlen(product)) == 0)
-		return true;
-	if (strncmp(td->tlv_product_name[1], product, strlen(product)) == 0)
-		return true;
-
-	return false;
-}
diff --git a/board/solidrun/common/tlv_data.h b/board/solidrun/common/tlv_data.h
deleted file mode 100644
index a1432e4b8e..0000000000
--- a/board/solidrun/common/tlv_data.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * Copyright 2020 SolidRun
- */
-
-#ifndef __BOARD_SR_COMMON_H_
-#define __BOARD_SR_COMMON_H_
-
-struct tlv_data {
-	/* Store product name of both SOM and carrier */
-	char tlv_product_name[2][32];
-	unsigned int ram_size;
-};
-
-void read_tlv_data(struct tlv_data *td);
-bool sr_product_is(const struct tlv_data *td, const char *product);
-
-#endif /* __BOARD_SR_COMMON_H_ */
diff --git a/board/solidrun/imx8mn_solidrun/imx8mn_solidrun.c b/board/solidrun/imx8mn_solidrun/imx8mn_solidrun.c
index 7ae863fd86..718fe0a4b8 100644
--- a/board/solidrun/imx8mn_solidrun/imx8mn_solidrun.c
+++ b/board/solidrun/imx8mn_solidrun/imx8mn_solidrun.c
@@ -15,7 +15,6 @@
 #include <asm/mach-imx/mxc_i2c.h>
 #include <i2c.h>
 #include <asm/io.h>
-#include "../common/tcpc.h"
 #include <usb.h>
 
 DECLARE_GLOBAL_DATA_PTR;
@@ -122,180 +121,6 @@ int board_phy_config(struct phy_device *phydev)
 }
 #endif
 
-#ifdef CONFIG_USB_TCPC
-struct tcpc_port port1;
-struct tcpc_port port2;
-
-static int setup_pd_switch(uint8_t i2c_bus, uint8_t addr)
-{
-	struct udevice *bus;
-	struct udevice *i2c_dev = NULL;
-	int ret;
-	uint8_t valb;
-
-	ret = uclass_get_device_by_seq(UCLASS_I2C, i2c_bus, &bus);
-	if (ret) {
-		printf("%s: Can't find bus\n", __func__);
-		return -EINVAL;
-	}
-
-	ret = dm_i2c_probe(bus, addr, 0, &i2c_dev);
-	if (ret) {
-		printf("%s: Can't find device id=0x%x\n",
-			__func__, addr);
-		return -ENODEV;
-	}
-
-	ret = dm_i2c_read(i2c_dev, 0xB, &valb, 1);
-	if (ret) {
-		printf("%s dm_i2c_read failed, err %d\n", __func__, ret);
-		return -EIO;
-	}
-	valb |= 0x4; /* Set DB_EXIT to exit dead battery mode */
-	ret = dm_i2c_write(i2c_dev, 0xB, (const uint8_t *)&valb, 1);
-	if (ret) {
-		printf("%s dm_i2c_write failed, err %d\n", __func__, ret);
-		return -EIO;
-	}
-
-	/* Set OVP threshold to 23V */
-	valb = 0x6;
-	ret = dm_i2c_write(i2c_dev, 0x8, (const uint8_t *)&valb, 1);
-	if (ret) {
-		printf("%s dm_i2c_write failed, err %d\n", __func__, ret);
-		return -EIO;
-	}
-
-	return 0;
-}
-
-int pd_switch_snk_enable(struct tcpc_port *port)
-{
-	if (port == &port1) {
-		debug("Setup pd switch on port 1\n");
-		return setup_pd_switch(1, 0x72);
-	} else if (port == &port2) {
-		debug("Setup pd switch on port 2\n");
-		return setup_pd_switch(1, 0x73);
-	} else
-		return -EINVAL;
-}
-
-struct tcpc_port_config port1_config = {
-	.i2c_bus = 1, /*i2c2*/
-	.addr = 0x50,
-	.port_type = TYPEC_PORT_UFP,
-	.max_snk_mv = 5000,
-	.max_snk_ma = 3000,
-	.max_snk_mw = 40000,
-	.op_snk_mv = 9000,
-	.switch_setup_func = &pd_switch_snk_enable,
-};
-
-struct tcpc_port_config port2_config = {
-	.i2c_bus = 1, /*i2c2*/
-	.addr = 0x52,
-	.port_type = TYPEC_PORT_UFP,
-	.max_snk_mv = 9000,
-	.max_snk_ma = 3000,
-	.max_snk_mw = 40000,
-	.op_snk_mv = 9000,
-	.switch_setup_func = &pd_switch_snk_enable,
-};
-
-static int setup_typec(void)
-{
-	int ret;
-
-	debug("tcpc_init port 2\n");
-	ret = tcpc_init(&port2, port2_config, NULL);
-	if (ret) {
-		printf("%s: tcpc port2 init failed, err=%d\n",
-		       __func__, ret);
-	} else if (tcpc_pd_sink_check_charging(&port2)) {
-		/* Disable PD for USB1, since USB2 has priority */
-		port1_config.disable_pd = true;
-		printf("Power supply on USB2\n");
-	}
-
-	debug("tcpc_init port 1\n");
-	ret = tcpc_init(&port1, port1_config, NULL);
-	if (ret) {
-		printf("%s: tcpc port1 init failed, err=%d\n",
-		       __func__, ret);
-	} else {
-		if (!port1_config.disable_pd)
-			printf("Power supply on USB1\n");
-		return ret;
-	}
-
-	return ret;
-}
-
-int board_usb_init(int index, enum usb_init_type init)
-{
-	int ret = 0;
-	struct tcpc_port *port_ptr;
-
-	debug("board_usb_init %d, type %d\n", index, init);
-
-	if (index == 0)
-		port_ptr = &port1;
-	else
-		port_ptr = &port2;
-
-	imx8m_usb_power(index, true);
-
-	if (init == USB_INIT_HOST)
-		tcpc_setup_dfp_mode(port_ptr);
-	else
-		tcpc_setup_ufp_mode(port_ptr);
-
-	return ret;
-}
-
-int board_usb_cleanup(int index, enum usb_init_type init)
-{
-	int ret = 0;
-
-	debug("board_usb_cleanup %d, type %d\n", index, init);
-
-	if (init == USB_INIT_HOST) {
-		if (index == 0)
-			ret = tcpc_disable_src_vbus(&port1);
-		else
-			ret = tcpc_disable_src_vbus(&port2);
-	}
-
-	imx8m_usb_power(index, false);
-	return ret;
-}
-
-int board_ehci_usb_phy_mode(struct udevice *dev)
-{
-	int ret = 0;
-	enum typec_cc_polarity pol;
-	enum typec_cc_state state;
-	struct tcpc_port *port_ptr;
-
-	if (dev->req_seq == 0)
-		port_ptr = &port1;
-	else
-		port_ptr = &port2;
-
-	tcpc_setup_ufp_mode(port_ptr);
-
-	ret = tcpc_get_cc_status(port_ptr, &pol, &state);
-	if (!ret) {
-		if (state == TYPEC_STATE_SRC_RD_RA || state == TYPEC_STATE_SRC_RD)
-			return USB_INIT_HOST;
-	}
-
-	return USB_INIT_DEVICE;
-}
-
-#endif
-
 #define FSL_SIP_GPC			0xC2000000
 #define FSL_SIP_CONFIG_GPC_PM_DOMAIN	0x3
 #define DISPMIX				9
@@ -303,10 +128,6 @@ int board_ehci_usb_phy_mode(struct udevice *dev)
 
 int board_init(void)
 {
-#ifdef CONFIG_USB_TCPC
-	setup_typec();
-#endif
-
 	if (IS_ENABLED(CONFIG_FEC_MXC))
 		setup_fec();
 
@@ -394,7 +215,7 @@ int check_power_connection(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]) {
 		break;
 		
 		case '2':
-			printf("Power check - boot once power is connected and capacitor charge is 90%\n");
+			printf("Power check - boot once power is connected and capacitor charge is 90%%\n");
 		break;
 
 		default: /*ilegal mode, ignore function and boot*/
diff --git a/configs/imx8mn_solidrun_defconfig b/configs/imx8mn_solidrun_defconfig
index 89223c99ef..bb2052c18a 100644
--- a/configs/imx8mn_solidrun_defconfig
+++ b/configs/imx8mn_solidrun_defconfig
@@ -39,11 +39,7 @@ CONFIG_SPL_POWER_SUPPORT=y
 CONFIG_NR_DRAM_BANKS=2
 CONFIG_HUSH_PARSER=y
 CONFIG_SYS_PROMPT="u-boot=> "
-# CONFIG_CMD_EXPORTENV is not set
-# CONFIG_CMD_IMPORTENV is not set
 CONFIG_CMD_ERASEENV=y
-# CONFIG_CMD_CRC32 is not set
-# CONFIG_BOOTM_NETBSD is not set
 CONFIG_CMD_CLK=y
 CONFIG_CMD_FUSE=y
 CONFIG_CMD_GPIO=y
@@ -117,7 +113,6 @@ CONFIG_SYSRESET=y
 CONFIG_SYSRESET_PSCI=y
 CONFIG_DM_THERMAL=y
 CONFIG_NXP_TMU=y
-CONFIG_USB_TCPC=y
 CONFIG_USB=y
 CONFIG_USB_GADGET=y
 CONFIG_DM_USB=y
-- 
2.25.1

