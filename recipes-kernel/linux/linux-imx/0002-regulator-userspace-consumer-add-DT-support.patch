From b90814381576de749af3db983cbefdf2599ec1e5 Mon Sep 17 00:00:00 2001
From: Laxman Dewangan <ldewangan@...dia.com>
Date: Wed, 30 Jul 2014 19:23:59 +0530
Subject: regulator: userspace-consumer: add DT support

NOTE: this is a slightly modified from existing patch due to merge conflict

Add DT support of the regulator driver userspace-consumer.
The supply names for this driver is provided through DT properties
so that proper regulator handle can be acquired.

Signed-off-by: Laxman Dewangan <ldewangan@...dia.com>
---
 drivers/regulator/userspace-consumer.c | 48 ++++++++++++++++++++------
 1 file changed, 38 insertions(+), 10 deletions(-)

diff --git a/drivers/regulator/userspace-consumer.c b/drivers/regulator/userspace-consumer.c
index cb1de24b9862..e1613756b199 100644
--- a/drivers/regulator/userspace-consumer.c
+++ b/drivers/regulator/userspace-consumer.c
@@ -115,9 +115,43 @@ static const struct attribute_group attr_group = {
 	.is_visible =  attr_visible,
 };
 
+static struct regulator_userspace_consumer_data *get_pdata_from_dt_node(
+		struct platform_device *pdev)
+{
+	struct regulator_userspace_consumer_data *pdata;
+	struct device_node *np = pdev->dev.of_node;
+	struct property *prop;
+	const char *supply;
+	int num_supplies;
+	int count = 0;
+
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return ERR_PTR(-ENOMEM);
+
+	pdata->name = of_get_property(np, "regulator-name", NULL);
+	pdata->init_on = of_property_read_bool(np, "regulator-boot-on");
+
+	num_supplies = of_property_count_strings(np, "regulator-supplies");
+	if (num_supplies < 0) {
+		dev_err(&pdev->dev,
+			"could not parse property regulator-supplies\n");
+		return ERR_PTR(-EINVAL);
+	}
+	pdata->num_supplies = num_supplies;
+	pdata->supplies = devm_kzalloc(&pdev->dev, num_supplies *
+				sizeof(*pdata->supplies), GFP_KERNEL);
+	if (!pdata->supplies)
+		return ERR_PTR(-ENOMEM);
+
+	of_property_for_each_string(np, "regulator-supplies", prop, supply)
+		pdata->supplies[count++].supply = supply;
+
+	return pdata;
+}
+
 static int regulator_userspace_consumer_probe(struct platform_device *pdev)
 {
-	struct regulator_userspace_consumer_data tmpdata;
 	struct regulator_userspace_consumer_data *pdata;
 	struct userspace_consumer_data *drvdata;
 	int ret;
@@ -127,15 +161,9 @@ static int regulator_userspace_consumer_probe(struct platform_device *pdev)
 		if (!pdev->dev.of_node)
 			return -EINVAL;
 
-		pdata = &tmpdata;
-		memset(pdata, 0, sizeof(*pdata));
-
-		pdata->no_autoswitch = true;
-		pdata->num_supplies = 1;
-		pdata->supplies = devm_kzalloc(&pdev->dev, sizeof(*pdata->supplies), GFP_KERNEL);
-		if (!pdata->supplies)
-			return -ENOMEM;
-		pdata->supplies[0].supply = "vout";
+		pdata = get_pdata_from_dt_node(pdev);
+		if (IS_ERR(pdata))
+			return PTR_ERR(pdata);
 	}
 
 	if (pdata->num_supplies < 1) {
-- 
2.39.2