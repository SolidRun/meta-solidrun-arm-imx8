From 2b8a527de61fb62c3756302a7fccf2c0dc244600 Mon Sep 17 00:00:00 2001
From: Michael Singer <michael.singer@baslerweb.com>
Date: Thu, 29 Aug 2019 15:23:55 +0200
Subject: [PATCH] quick fix open&close in mx6s_capture.c

Before: CSI hardware gets reset whenever video device file gets opened or closed.
        --> Streaming stops.

After: Adds an open counter and only resets the hardware on the first
       open and the last close.
       --> Streaming still works.
---
 .../media/platform/mxc/capture/mx6s_capture.c | 80 +++++++++++--------
 1 file changed, 45 insertions(+), 35 deletions(-)

diff --git a/drivers/media/platform/mxc/capture/mx6s_capture.c b/drivers/media/platform/mxc/capture/mx6s_capture.c
index 2d8dc4cfcccc..3ade5e22af45 100755
--- a/drivers/media/platform/mxc/capture/mx6s_capture.c
+++ b/drivers/media/platform/mxc/capture/mx6s_capture.c
@@ -361,6 +361,8 @@ struct mx6s_csi_dev {
 	/* pointers to "struct bridge_subdev -> asd" */
 	struct v4l2_async_subdev **asds;
 
+	int open_count;
+
 	bool csi_mipi_mode;
 	bool csi_two_8bit_sensor_mode;
 	const struct mx6s_csi_soc *soc;
@@ -1215,30 +1217,34 @@ static int mx6s_csi_open(struct file *file)
 	if (mutex_lock_interruptible(&csi_dev->lock))
 		return -ERESTARTSYS;
 
-	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	q->io_modes = VB2_MMAP | VB2_USERPTR;
-	q->drv_priv = csi_dev;
-	q->ops = &mx6s_videobuf_ops;
-	q->mem_ops = &vb2_dma_contig_memops;
-	q->buf_struct_size = sizeof(struct mx6s_buffer);
-	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
-	q->lock = &csi_dev->lock;
+	BUG_ON(csi_dev->open_count < 0);
 
-	ret = vb2_queue_init(q);
-	if (ret < 0)
-		goto unlock;
 
-	pm_runtime_get_sync(csi_dev->dev);
+	if (!csi_dev->open_count) {
+		q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		q->io_modes = VB2_MMAP | VB2_USERPTR;
+		q->drv_priv = csi_dev;
+		q->ops = &mx6s_videobuf_ops;
+		q->mem_ops = &vb2_dma_contig_memops;
+		q->buf_struct_size = sizeof(struct mx6s_buffer);
+		q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+		q->lock = &csi_dev->lock;
 
-	request_bus_freq(BUS_FREQ_HIGH);
+		ret = vb2_queue_init(q);
+		if (ret < 0)
+			goto unlock;
 
-	v4l2_subdev_call(subdevs[CSI2PHY].v4l2_sd, core, s_power, 1);
-	v4l2_subdev_call(subdevs[SENSOR].v4l2_sd, core, s_power, 1);
-	mx6s_csi_init(csi_dev);
+		pm_runtime_get_sync(csi_dev->dev);
 
-	mutex_unlock(&csi_dev->lock);
+		request_bus_freq(BUS_FREQ_HIGH);
+
+		v4l2_subdev_call(subdevs[CSI2PHY].v4l2_sd, core, s_power, 1);
+		v4l2_subdev_call(subdevs[SENSOR].v4l2_sd, core, s_power, 1);
+		mx6s_csi_init(csi_dev);
+	}
+
+	csi_dev->open_count++;
 
-	return ret;
 unlock:
 	mutex_unlock(&csi_dev->lock);
 	return ret;
@@ -1251,19 +1257,23 @@ static int mx6s_csi_close(struct file *file)
 
 	mutex_lock(&csi_dev->lock);
 
-	vb2_queue_release(&csi_dev->vb2_vidq);
+	BUG_ON(csi_dev->open_count <= 0);
+	csi_dev->open_count--;
 
-	mx6s_csi_deinit(csi_dev);
-	v4l2_subdev_call(subdevs[SENSOR].v4l2_sd, core, s_power, 0);
-	v4l2_subdev_call(subdevs[CSI2PHY].v4l2_sd, core, s_power, 0);
+	if (!csi_dev->open_count) {
+		vb2_queue_release(&csi_dev->vb2_vidq);
 
-	mutex_unlock(&csi_dev->lock);
+		mx6s_csi_deinit(csi_dev);
+		v4l2_subdev_call(subdevs[SENSOR].v4l2_sd, core, s_power, 0);
+		v4l2_subdev_call(subdevs[CSI2PHY].v4l2_sd, core, s_power, 0);
 
-	file->private_data = NULL;
+		release_bus_freq(BUS_FREQ_HIGH);
 
-	release_bus_freq(BUS_FREQ_HIGH);
+		pm_runtime_put_sync_suspend(csi_dev->dev);
+	}
 
-	pm_runtime_put_sync_suspend(csi_dev->dev);
+	file->private_data = NULL;
+	mutex_unlock(&csi_dev->lock);
 	return 0;
 }
 
@@ -1346,7 +1356,7 @@ static int mx6s_vidioc_reqbufs(struct file *file, void *priv,
 {
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
 
-	WARN_ON(priv != file->private_data);
+	BUG_ON(priv != file->private_data);
 
 	return vb2_reqbufs(&csi_dev->vb2_vidq, p);
 }
@@ -1357,7 +1367,7 @@ static int mx6s_vidioc_querybuf(struct file *file, void *priv,
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
 	int ret;
 
-	WARN_ON(priv != file->private_data);
+	BUG_ON(priv != file->private_data);
 
 	ret = vb2_querybuf(&csi_dev->vb2_vidq, p);
 
@@ -1375,7 +1385,7 @@ static int mx6s_vidioc_qbuf(struct file *file, void *priv,
 {
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
 
-	WARN_ON(priv != file->private_data);
+	BUG_ON(priv != file->private_data);
 
 	return vb2_qbuf(&csi_dev->vb2_vidq, p);
 }
@@ -1385,7 +1395,7 @@ static int mx6s_vidioc_dqbuf(struct file *file, void *priv,
 {
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
 
-	WARN_ON(priv != file->private_data);
+	BUG_ON(priv != file->private_data);
 
 	return vb2_dqbuf(&csi_dev->vb2_vidq, p, file->f_flags & O_NONBLOCK);
 }
@@ -1402,7 +1412,7 @@ static int mx6s_vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 	struct mx6s_fmt *fmt;
 	int ret;
 
-	WARN_ON(priv != file->private_data);
+	BUG_ON(priv != file->private_data);
 
 	ret = v4l2_subdev_call(subdevs[SENSOR].v4l2_sd, pad, enum_mbus_code, NULL, &code);
 	if (ret < 0) {
@@ -1497,7 +1507,7 @@ static int mx6s_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
 {
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
 
-	WARN_ON(priv != file->private_data);
+	BUG_ON(priv != file->private_data);
 
 	f->fmt.pix = csi_dev->pix;
 
@@ -1509,7 +1519,7 @@ static int mx6s_vidioc_querycap(struct file *file, void  *priv,
 {
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
 
-	WARN_ON(priv != file->private_data);
+	BUG_ON(priv != file->private_data);
 
 	/* cap->name is set by the friendly caller:-> */
 	strlcpy(cap->driver, MX6S_CAM_DRV_NAME, sizeof(cap->driver));
@@ -1540,7 +1550,7 @@ static int mx6s_vidioc_streamon(struct file *file, void *priv,
 	struct bridge_subdev *subdevs = csi_dev->subdevs;
 	int ret;
 
-	WARN_ON(priv != file->private_data);
+	BUG_ON(priv != file->private_data);
 
 	if (i != V4L2_BUF_TYPE_VIDEO_CAPTURE)
 		return -EINVAL;
@@ -1560,7 +1570,7 @@ static int mx6s_vidioc_streamoff(struct file *file, void *priv,
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
 	struct bridge_subdev *subdevs = csi_dev->subdevs;
 
-	WARN_ON(priv != file->private_data);
+	BUG_ON(priv != file->private_data);
 
 	if (i != V4L2_BUF_TYPE_VIDEO_CAPTURE)
 		return -EINVAL;
-- 
2.21.0

