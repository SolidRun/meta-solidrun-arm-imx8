From d519e10b5f28a5805b4550cde25bc48cae65746d Mon Sep 17 00:00:00 2001
From: sebastian suesens <sebastian.suesens@baslerweb.com>
Date: Tue, 23 Apr 2019 08:55:18 +0200
Subject: [PATCH] changed video device driver structure to get sensor controls 
 to user space

If the sensor is registered by the csi2 phy, the video device driver does
not know about the sensor, thus the video device driver can't access the
controls from the sensor.
Now the csi2 phy and the sensor is registered by the video device driver.
---
 .../boot/dts/freescale/fsl-imx8mq-evk.dts     |  31 +-
 drivers/media/platform/imx8/mxc-mipi-csi2.h   |   3 +
 .../media/platform/imx8/mxc-mipi-csi2_yav.c   | 141 +--------
 .../media/platform/mxc/capture/mx6s_capture.c | 284 +++++++++++-------
 4 files changed, 195 insertions(+), 264 deletions(-)

diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-evk.dts b/arch/arm64/boot/dts/freescale/fsl-imx8mq-evk.dts
old mode 100644
new mode 100755
index a9d93cb67324..2c0a6437fcab
--- a/arch/arm64/boot/dts/freescale/fsl-imx8mq-evk.dts
+++ b/arch/arm64/boot/dts/freescale/fsl-imx8mq-evk.dts
@@ -935,9 +935,15 @@
 	status = "okay";
 
 	port {
-		csi1_ep: endpoint {
+
+		csi1_ep: endpoint1 {
+			reg = <0>;
 			remote-endpoint = <&csi1_mipi_ep>;
 		};
+		mipi1_sensor_ep: endpoint2 {
+			reg = <1>;
+			remote-endpoint = <&ov5640_mipi1_ep>;
+		};
 	};
 };
 
@@ -947,9 +953,14 @@
 	status = "okay";
 
 	port {
-		csi2_ep: endpoint {
+		csi2_ep: endpoint1 {
+			reg = <0>;
 			remote-endpoint = <&csi2_mipi_ep>;
 		};
+		mipi2_sensor_ep: endpoint2 {
+			reg = <1>;
+			remote-endpoint = <&ov5640_mipi2_ep>;
+		};
 	};
 };
 
@@ -958,13 +969,9 @@
 	#size-cells = <0>;
 	status = "okay";
 	port {
-		mipi1_sensor_ep: endpoint1 {
-			remote-endpoint = <&ov5640_mipi1_ep>;
-			data-lanes = <1 2>;
-		};
-
-		csi1_mipi_ep: endpoint2 {
+		csi1_mipi_ep: endpoint {
 			remote-endpoint = <&csi1_ep>;
+			data-lanes = <1 2>;
 		};
 	};
 };
@@ -974,13 +981,9 @@
 	#size-cells = <0>;
 	status = "okay";
 	port {
-		mipi2_sensor_ep: endpoint1 {
-			remote-endpoint = <&ov5640_mipi2_ep>;
-			data-lanes = <1 2>;
-		};
-
-		csi2_mipi_ep: endpoint2 {
+		csi2_mipi_ep: endpoint {
 			remote-endpoint = <&csi2_ep>;
+			data-lanes = <1 2>;
 		};
 	};
 };
diff --git a/drivers/media/platform/imx8/mxc-mipi-csi2.h b/drivers/media/platform/imx8/mxc-mipi-csi2.h
old mode 100644
new mode 100755
index ed01adc1958b..ff069aa7a6ab
--- a/drivers/media/platform/imx8/mxc-mipi-csi2.h
+++ b/drivers/media/platform/imx8/mxc-mipi-csi2.h
@@ -14,6 +14,7 @@
 #define MXC_MIPI_CSI2_H_
 
 #include <media/v4l2-device.h>
+#include <media/v4l2-ctrls.h>
 
 #define MXC_MIPI_CSI2_DRIVER_NAME	"mxc-mipi-csi2"
 #define MXC_MIPI_CSI2_SUBDEV_NAME	MXC_MIPI_CSI2_DRIVER_NAME
@@ -238,6 +239,8 @@ struct mxc_mipi_csi2_dev {
 	struct v4l2_subdev		sd;
 	struct v4l2_subdev		*sensor_sd;
 
+	struct v4l2_ctrl_handler   ctrl_handler;
+
 	struct media_pad pads[MXC_MIPI_CSI2_VCX_PADS_NUM];
 	struct v4l2_mbus_framefmt format;
 
diff --git a/drivers/media/platform/imx8/mxc-mipi-csi2_yav.c b/drivers/media/platform/imx8/mxc-mipi-csi2_yav.c
old mode 100644
new mode 100755
index abeb38279962..bf08d7f66495
--- a/drivers/media/platform/imx8/mxc-mipi-csi2_yav.c
+++ b/drivers/media/platform/imx8/mxc-mipi-csi2_yav.c
@@ -320,7 +320,6 @@ static int mipi_csi2_s_stream(struct v4l2_subdev *sd, int enable)
 {
 	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
 	struct device *dev = &csi2dev->pdev->dev;
-	struct v4l2_subdev *sensor_sd = csi2dev->sensor_sd;
 	int ret = 0;
 
 	dev_dbg(&csi2dev->pdev->dev, "%s: %d, csi2dev: 0x%x\n",
@@ -334,12 +333,10 @@ static int mipi_csi2_s_stream(struct v4l2_subdev *sd, int enable)
 			mxc_mipi_csi2_enable(csi2dev);
 			mxc_mipi_csi2_reg_dump(csi2dev);
 		}
-		v4l2_subdev_call(sensor_sd, video, s_stream, true);
 		csi2dev->running++;
 
 	} else {
 
-		v4l2_subdev_call(sensor_sd, video, s_stream, false);
 		csi2dev->running--;
 		if (!csi2dev->running) {
 			pm_runtime_put(dev);
@@ -350,56 +347,11 @@ static int mipi_csi2_s_stream(struct v4l2_subdev *sd, int enable)
 	return ret;
 }
 
-static int mipi_csis_enum_framesizes(struct v4l2_subdev *sd,
-				     struct v4l2_subdev_pad_config *cfg,
-				     struct v4l2_subdev_frame_size_enum *fse)
-{
-	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
-	struct v4l2_subdev *sensor_sd = csi2dev->sensor_sd;
-
-	return v4l2_subdev_call(sensor_sd, pad, enum_frame_size, NULL, fse);
-}
-
-static int mipi_csis_enum_frameintervals(struct v4l2_subdev *sd,
-					 struct v4l2_subdev_pad_config *cfg,
-					 struct v4l2_subdev_frame_interval_enum
-					 *fie)
-{
-	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
-	struct v4l2_subdev *sensor_sd = csi2dev->sensor_sd;
-
-	return v4l2_subdev_call(sensor_sd, pad, enum_frame_interval, NULL, fie);
-}
-
-static int mipi_csis_enum_mbus_code(struct v4l2_subdev *sd,
-				    struct v4l2_subdev_pad_config *cfg,
-				    struct v4l2_subdev_mbus_code_enum *code)
-{
-	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
-	struct v4l2_subdev *sensor_sd = csi2dev->sensor_sd;
-
-	return v4l2_subdev_call(sensor_sd, pad, enum_mbus_code, NULL, code);
-}
-
-static int mipi_csi2_get_fmt(struct v4l2_subdev *sd,
-			     struct v4l2_subdev_pad_config *cfg,
-			     struct v4l2_subdev_format *fmt)
-{
-	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
-	struct v4l2_subdev *sensor_sd = csi2dev->sensor_sd;
-
-	if (fmt->pad)
-		return -EINVAL;
-
-	return v4l2_subdev_call(sensor_sd, pad, get_fmt, NULL, fmt);
-}
-
 static int mipi_csi2_set_fmt(struct v4l2_subdev *sd,
 			     struct v4l2_subdev_pad_config *cfg,
 			     struct v4l2_subdev_format *fmt)
 {
 	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
-	struct v4l2_subdev *sensor_sd = csi2dev->sensor_sd;
 
 	if (fmt->pad)
 		return -EINVAL;
@@ -411,23 +363,7 @@ static int mipi_csi2_set_fmt(struct v4l2_subdev *sd,
 	}
 	csi2dev->send_level = 64;
 
-	return v4l2_subdev_call(sensor_sd, pad, set_fmt, NULL, fmt);
-}
-
-static int mipi_csis_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
-{
-	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
-	struct v4l2_subdev *sensor_sd = csi2dev->sensor_sd;
-
-	return v4l2_subdev_call(sensor_sd, video, s_parm, a);
-}
-
-static int mipi_csis_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *a)
-{
-	struct mxc_mipi_csi2_dev *csi2dev = sd_to_mxc_mipi_csi2_dev(sd);
-	struct v4l2_subdev *sensor_sd = csi2dev->sensor_sd;
-
-	return v4l2_subdev_call(sensor_sd, video, g_parm, a);
+	return 0;
 }
 
 static const struct v4l2_subdev_internal_ops mipi_csi2_sd_internal_ops = {
@@ -435,10 +371,6 @@ static const struct v4l2_subdev_internal_ops mipi_csi2_sd_internal_ops = {
 };
 
 static struct v4l2_subdev_pad_ops mipi_csi2_pad_ops = {
-	.enum_frame_size = mipi_csis_enum_framesizes,
-	.enum_frame_interval = mipi_csis_enum_frameintervals,
-	.enum_mbus_code = mipi_csis_enum_mbus_code,
-	.get_fmt = mipi_csi2_get_fmt,
 	.set_fmt = mipi_csi2_set_fmt,
 };
 
@@ -448,9 +380,6 @@ static struct v4l2_subdev_core_ops mipi_csi2_core_ops = {
 
 static struct v4l2_subdev_video_ops mipi_csi2_video_ops = {
 	.s_stream = mipi_csi2_s_stream,
-
-	.s_parm = mipi_csis_s_parm,
-	.g_parm = mipi_csis_g_parm,
 };
 
 static struct v4l2_subdev_ops mipi_csi2_subdev_ops = {
@@ -501,8 +430,10 @@ static int subdev_notifier_bound(struct v4l2_async_notifier *notifier,
 	struct mxc_mipi_csi2_dev *csi2dev = notifier_to_mipi_dev(notifier);
 
 	/* Find platform data for this sensor subdev */
-	if (csi2dev->asd.match.fwnode.fwnode == of_fwnode_handle(subdev->dev->of_node))
+	if (csi2dev->asd.match.fwnode.fwnode == of_fwnode_handle(subdev->dev->of_node)){
 		csi2dev->sensor_sd = subdev;
+		csi2dev->sd.ctrl_handler = subdev->ctrl_handler;
+	}
 
 	if (subdev == NULL)
 		return -EINVAL;
@@ -513,56 +444,6 @@ static int subdev_notifier_bound(struct v4l2_async_notifier *notifier,
 	return 0;
 }
 
-static int mipi_csis_subdev_host(struct mxc_mipi_csi2_dev *csi2dev)
-{
-	struct device *dev = &csi2dev->pdev->dev;
-	struct device_node *parent = dev->of_node;
-	struct device_node *node, *port, *rem;
-	int ret;
-
-	/* Attach sensors linked to csi receivers */
-	for_each_available_child_of_node(parent, node) {
-		if (of_node_cmp(node->name, "port"))
-			continue;
-
-		/* The csi node can have only port subnode. */
-		port = of_get_next_child(node, NULL);
-		if (!port)
-			continue;
-		rem = of_graph_get_remote_port_parent(port);
-		of_node_put(port);
-		if (rem == NULL) {
-			v4l2_info(&csi2dev->v4l2_dev,
-				  "Remote device at %s not found\n",
-				  port->full_name);
-			return -1;
-		} else
-			v4l2_info(&csi2dev->v4l2_dev,
-				  "Remote device at %s XXX found\n",
-				  port->full_name);
-
-		csi2dev->asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
-		csi2dev->asd.match.fwnode.fwnode = of_fwnode_handle(rem);
-		csi2dev->async_subdevs[0] = &csi2dev->asd;
-
-		of_node_put(rem);
-		break;
-	}
-
-	csi2dev->subdev_notifier.subdevs = csi2dev->async_subdevs;
-	csi2dev->subdev_notifier.num_subdevs = 1;
-	csi2dev->subdev_notifier.bound = subdev_notifier_bound;
-
-	ret = v4l2_async_notifier_register(&csi2dev->v4l2_dev,
-					   &csi2dev->subdev_notifier);
-	if (ret)
-		dev_err(dev,
-			"Error register async notifier regoster, ret %d\n",
-			ret);
-
-	return ret;
-}
-
 static int mipi_csi2_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -614,19 +495,9 @@ static int mipi_csi2_probe(struct platform_device *pdev)
 		goto e_v4l_dev;
 	}
 
-	ret = mipi_csis_subdev_host(csi2dev);
-	if (ret < 0)
-		goto e_clkdis;
-
-	/* This allows to retrieve the platform device id by the host driver */
-	v4l2_set_subdevdata(&csi2dev->sd, pdev);
-
-	/* .. and a pointer to the subdev. */
-	platform_set_drvdata(pdev, csi2dev);
-
 	ret = mipi_csi2_clk_enable(csi2dev);
 	if (ret < 0)
-		goto e_clkdis;
+		goto e_v4l_dev;
 
 	dev_info(&pdev->dev, "lanes: %d, name: %s\n",
 		 csi2dev->num_lanes, csi2dev->sd.name);
@@ -637,8 +508,6 @@ static int mipi_csi2_probe(struct platform_device *pdev)
 
 	return 0;
 
-e_clkdis:
-	v4l2_async_unregister_subdev(&csi2dev->sd);
 e_v4l_dev:
 	v4l2_device_unregister(&csi2dev->v4l2_dev);
 	return ret;
diff --git a/drivers/media/platform/mxc/capture/mx6s_capture.c b/drivers/media/platform/mxc/capture/mx6s_capture.c
old mode 100644
new mode 100755
index a1f885dcc834..48a2a8fcfb39
--- a/drivers/media/platform/mxc/capture/mx6s_capture.c
+++ b/drivers/media/platform/mxc/capture/mx6s_capture.c
@@ -49,6 +49,7 @@
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-dev.h>
 #include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
 #include <media/v4l2-ioctl.h>
 #include <media/videobuf2-core.h>
 #include <media/videobuf2-dma-contig.h>
@@ -179,6 +180,9 @@
 #define NUM_FORMATS ARRAY_SIZE(formats)
 #define MX6SX_MAX_SENSORS    1
 
+#define CSI2PHY 			0
+#define SENSOR 				1
+
 struct csi_signal_cfg_t {
 	unsigned data_width:3;
 	unsigned clk_mode:2;
@@ -303,7 +307,6 @@ struct mx6s_csi_soc {
 struct mx6s_csi_dev {
 	struct device		*dev;
 	struct video_device *vdev;
-	struct v4l2_subdev	*sd;
 	struct v4l2_device	v4l2_dev;
 
 	struct vb2_queue			vb2_vidq;
@@ -340,9 +343,17 @@ struct mx6s_csi_dev {
 	size_t						discard_size;
 	struct mx6s_buf_internal	buf_discard[2];
 
-	struct v4l2_async_subdev	asd;
-	struct v4l2_async_notifier	subdev_notifier;
-	struct v4l2_async_subdev	*async_subdevs[2];
+	/* subdevices descriptors */
+	struct bridge_subdev	*subdevs;
+	/* the subdevice currently in use */
+	struct bridge_subdev	*sd;
+	unsigned int		sd_index;
+	unsigned int		num_sd;
+
+	/* async subdev notification helpers */
+	struct v4l2_async_notifier notifier;
+	/* pointers to "struct bridge_subdev -> asd" */
+	struct v4l2_async_subdev **asds;
 
 	bool csi_mipi_mode;
 	bool csi_two_8bit_sensor_mode;
@@ -350,6 +361,19 @@ struct mx6s_csi_dev {
 	struct mx6s_csi_mux csi_mux;
 };
 
+/*
+ * bridge_subdev - Wraps v4l2 sub-device and provides async subdevice.
+ */
+struct bridge_subdev {
+	struct v4l2_subdev *v4l2_sd;
+	struct v4l2_async_subdev asd;
+};
+
+static struct bridge_subdev *to_bridge_subdev(struct v4l2_async_subdev *asd)
+{
+	return container_of(asd, struct bridge_subdev, asd);
+}
+
 static const struct of_device_id mx6s_csi_dt_ids[];
 
 static inline int csi_read(struct mx6s_csi_dev *csi, unsigned int offset)
@@ -362,12 +386,6 @@ static inline void csi_write(struct mx6s_csi_dev *csi, unsigned int value,
 	__raw_writel(value, csi->regbase + offset);
 }
 
-static inline struct mx6s_csi_dev
-				*notifier_to_mx6s_dev(struct v4l2_async_notifier *n)
-{
-	return container_of(n, struct mx6s_csi_dev, subdev_notifier);
-}
-
 struct mx6s_fmt *format_by_fourcc(int fourcc)
 {
 	int i;
@@ -1180,7 +1198,7 @@ static irqreturn_t mx6s_csi_irq_handler(int irq, void *data)
 static int mx6s_csi_open(struct file *file)
 {
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
-	struct v4l2_subdev *sd = csi_dev->sd;
+	struct bridge_subdev *subdevs = csi_dev->subdevs;
 	struct vb2_queue *q = &csi_dev->vb2_vidq;
 	int ret = 0;
 
@@ -1206,7 +1224,8 @@ static int mx6s_csi_open(struct file *file)
 
 	request_bus_freq(BUS_FREQ_HIGH);
 
-	v4l2_subdev_call(sd, core, s_power, 1);
+	v4l2_subdev_call(subdevs[CSI2PHY].v4l2_sd, core, s_power, 1);
+	v4l2_subdev_call(subdevs[SENSOR].v4l2_sd, core, s_power, 1);
 	mx6s_csi_init(csi_dev);
 
 	mutex_unlock(&csi_dev->lock);
@@ -1220,14 +1239,15 @@ static int mx6s_csi_open(struct file *file)
 static int mx6s_csi_close(struct file *file)
 {
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
-	struct v4l2_subdev *sd = csi_dev->sd;
+	struct bridge_subdev *subdevs = csi_dev->subdevs;
 
 	mutex_lock(&csi_dev->lock);
 
 	vb2_queue_release(&csi_dev->vb2_vidq);
 
 	mx6s_csi_deinit(csi_dev);
-	v4l2_subdev_call(sd, core, s_power, 0);
+	v4l2_subdev_call(subdevs[SENSOR].v4l2_sd, core, s_power, 0);
+	v4l2_subdev_call(subdevs[CSI2PHY].v4l2_sd, core, s_power, 0);
 
 	mutex_unlock(&csi_dev->lock);
 
@@ -1313,30 +1333,6 @@ static int mx6s_vidioc_s_input(struct file *file, void *priv, unsigned int i)
 	return 0;
 }
 
-static int mx6s_vidioc_querystd(struct file *file, void *priv, v4l2_std_id *a)
-{
-	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
-	struct v4l2_subdev *sd = csi_dev->sd;
-
-	return v4l2_subdev_call(sd, video, querystd, a);
-}
-
-static int mx6s_vidioc_s_std(struct file *file, void *priv, v4l2_std_id a)
-{
-	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
-	struct v4l2_subdev *sd = csi_dev->sd;
-
-	return v4l2_subdev_call(sd, video, s_std, a);
-}
-
-static int mx6s_vidioc_g_std(struct file *file, void *priv, v4l2_std_id *a)
-{
-	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
-	struct v4l2_subdev *sd = csi_dev->sd;
-
-	return v4l2_subdev_call(sd, video, g_std, a);
-}
-
 static int mx6s_vidioc_reqbufs(struct file *file, void *priv,
 			      struct v4l2_requestbuffers *p)
 {
@@ -1390,7 +1386,7 @@ static int mx6s_vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 				       struct v4l2_fmtdesc *f)
 {
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
-	struct v4l2_subdev *sd = csi_dev->sd;
+	struct bridge_subdev *subdevs = csi_dev->subdevs;
 	struct v4l2_subdev_mbus_code_enum code = {
 		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
 		.index = f->index,
@@ -1400,7 +1396,7 @@ static int mx6s_vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
 
 	WARN_ON(priv != file->private_data);
 
-	ret = v4l2_subdev_call(sd, pad, enum_mbus_code, NULL, &code);
+	ret = v4l2_subdev_call(subdevs[SENSOR].v4l2_sd, pad, enum_mbus_code, NULL, &code);
 	if (ret < 0) {
 		/* no more formats */
 		dev_dbg(csi_dev->dev, "No more fmt\n");
@@ -1423,7 +1419,7 @@ static int mx6s_vidioc_try_fmt_vid_cap(struct file *file, void *priv,
 				      struct v4l2_format *f)
 {
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
-	struct v4l2_subdev *sd = csi_dev->sd;
+	struct bridge_subdev *subdevs = csi_dev->subdevs;
 	struct v4l2_pix_format *pix = &f->fmt.pix;
 	struct v4l2_subdev_format format = {
 		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
@@ -1445,7 +1441,8 @@ static int mx6s_vidioc_try_fmt_vid_cap(struct file *file, void *priv,
 	}
 
 	v4l2_fill_mbus_format(&format.format, pix, fmt->mbus_code);
-	ret = v4l2_subdev_call(sd, pad, set_fmt, NULL, &format);
+	ret = v4l2_subdev_call(subdevs[CSI2PHY].v4l2_sd, pad, set_fmt, NULL, &format);
+	ret = v4l2_subdev_call(subdevs[SENSOR].v4l2_sd, pad, set_fmt, NULL, &format);
 	v4l2_fill_pix_format(pix, &format.format);
 
 	if (pix->field != V4L2_FIELD_INTERLACED)
@@ -1532,7 +1529,7 @@ static int mx6s_vidioc_streamon(struct file *file, void *priv,
 			       enum v4l2_buf_type i)
 {
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
-	struct v4l2_subdev *sd = csi_dev->sd;
+	struct bridge_subdev *subdevs = csi_dev->subdevs;
 	int ret;
 
 	WARN_ON(priv != file->private_data);
@@ -1542,7 +1539,9 @@ static int mx6s_vidioc_streamon(struct file *file, void *priv,
 
 	ret = vb2_streamon(&csi_dev->vb2_vidq, i);
 	if (!ret)
-		v4l2_subdev_call(sd, video, s_stream, 1);
+
+		v4l2_subdev_call(subdevs[CSI2PHY].v4l2_sd, video, s_stream, true);
+		v4l2_subdev_call(subdevs[SENSOR].v4l2_sd, video, s_stream, true);
 
 	return ret;
 }
@@ -1551,7 +1550,7 @@ static int mx6s_vidioc_streamoff(struct file *file, void *priv,
 				enum v4l2_buf_type i)
 {
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
-	struct v4l2_subdev *sd = csi_dev->sd;
+	struct bridge_subdev *subdevs = csi_dev->subdevs;
 
 	WARN_ON(priv != file->private_data);
 
@@ -1563,8 +1562,8 @@ static int mx6s_vidioc_streamoff(struct file *file, void *priv,
 	 * remaining buffers. When the last buffer is freed, stop capture
 	 */
 	vb2_streamoff(&csi_dev->vb2_vidq, i);
-
-	v4l2_subdev_call(sd, video, s_stream, 0);
+	v4l2_subdev_call(subdevs[SENSOR].v4l2_sd, video, s_stream, false);
+	v4l2_subdev_call(subdevs[CSI2PHY].v4l2_sd, video, s_stream, false);
 
 	return 0;
 }
@@ -1610,25 +1609,25 @@ static int mx6s_vidioc_g_parm(struct file *file, void *priv,
 			     struct v4l2_streamparm *a)
 {
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
-	struct v4l2_subdev *sd = csi_dev->sd;
+	struct bridge_subdev *subdevs = csi_dev->subdevs;
 
-	return v4l2_subdev_call(sd, video, g_parm, a);
+	return v4l2_subdev_call(subdevs[SENSOR].v4l2_sd, video, g_parm, a);
 }
 
 static int mx6s_vidioc_s_parm(struct file *file, void *priv,
 				struct v4l2_streamparm *a)
 {
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
-	struct v4l2_subdev *sd = csi_dev->sd;
+	struct bridge_subdev *subdevs = csi_dev->subdevs;
 
-	return v4l2_subdev_call(sd, video, s_parm, a);
+	return v4l2_subdev_call(subdevs[SENSOR].v4l2_sd, video, s_parm, a);
 }
 
 static int mx6s_vidioc_enum_framesizes(struct file *file, void *priv,
 					 struct v4l2_frmsizeenum *fsize)
 {
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
-	struct v4l2_subdev *sd = csi_dev->sd;
+	struct bridge_subdev *subdevs = csi_dev->subdevs;
 	struct mx6s_fmt *fmt;
 	struct v4l2_subdev_frame_size_enum fse = {
 		.index = fsize->index,
@@ -1641,7 +1640,7 @@ static int mx6s_vidioc_enum_framesizes(struct file *file, void *priv,
 		return -EINVAL;
 	fse.code = fmt->mbus_code;
 
-	ret = v4l2_subdev_call(sd, pad, enum_frame_size, NULL, &fse);
+	ret = v4l2_subdev_call(subdevs[SENSOR].v4l2_sd, pad, enum_frame_size, NULL, &fse);
 	if (ret)
 		return ret;
 
@@ -1668,7 +1667,7 @@ static int mx6s_vidioc_enum_frameintervals(struct file *file, void *priv,
 		struct v4l2_frmivalenum *interval)
 {
 	struct mx6s_csi_dev *csi_dev = video_drvdata(file);
-	struct v4l2_subdev *sd = csi_dev->sd;
+	struct bridge_subdev *subdevs = csi_dev->subdevs;
 	struct mx6s_fmt *fmt;
 	struct v4l2_subdev_frame_interval_enum fie = {
 		.index = interval->index,
@@ -1683,7 +1682,7 @@ static int mx6s_vidioc_enum_frameintervals(struct file *file, void *priv,
 		return -EINVAL;
 	fie.code = fmt->mbus_code;
 
-	ret = v4l2_subdev_call(sd, pad, enum_frame_interval, NULL, &fie);
+	ret = v4l2_subdev_call(subdevs[SENSOR].v4l2_sd, pad, enum_frame_interval, NULL, &fie);
 	if (ret)
 		return ret;
 	interval->type = V4L2_FRMIVAL_TYPE_DISCRETE;
@@ -1704,9 +1703,6 @@ static const struct v4l2_ioctl_ops mx6s_csi_ioctl_ops = {
 	.vidioc_querybuf      = mx6s_vidioc_querybuf,
 	.vidioc_qbuf          = mx6s_vidioc_qbuf,
 	.vidioc_dqbuf         = mx6s_vidioc_dqbuf,
-	.vidioc_g_std         = mx6s_vidioc_g_std,
-	.vidioc_s_std         = mx6s_vidioc_s_std,
-	.vidioc_querystd      = mx6s_vidioc_querystd,
 	.vidioc_enum_input    = mx6s_vidioc_enum_input,
 	.vidioc_g_input       = mx6s_vidioc_g_input,
 	.vidioc_s_input       = mx6s_vidioc_s_input,
@@ -1719,25 +1715,117 @@ static const struct v4l2_ioctl_ops mx6s_csi_ioctl_ops = {
 	.vidioc_enum_frameintervals = mx6s_vidioc_enum_frameintervals,
 };
 
-static int subdev_notifier_bound(struct v4l2_async_notifier *notifier,
-			    struct v4l2_subdev *subdev,
+static inline struct mx6s_csi_dev *v4l2_to_bridge(struct v4l2_device *v4l2_dev)
+{
+	return container_of(v4l2_dev, struct mx6s_csi_dev, v4l2_dev);
+}
+
+static int bridge_notify_bound(struct v4l2_async_notifier *notifier,
+			    struct v4l2_subdev *v4l2_sd,
 			    struct v4l2_async_subdev *asd)
 {
-	struct mx6s_csi_dev *csi_dev = notifier_to_mx6s_dev(notifier);
+	struct v4l2_device *v4l2_dev = notifier->v4l2_dev;
+	struct mx6s_csi_dev *csi_dev = v4l2_to_bridge(v4l2_dev);
+	struct bridge_subdev *bridge_sd = to_bridge_subdev(asd);
 
-	/* Find platform data for this sensor subdev */
-	if (csi_dev->asd.match.fwnode.fwnode == dev_fwnode(subdev->dev))
-		csi_dev->sd = subdev;
+	bridge_sd->v4l2_sd = v4l2_sd;
+	csi_dev->num_sd++;
 
-	if (subdev == NULL)
-		return -EINVAL;
+	return 0;
+}
 
-	v4l2_info(&csi_dev->v4l2_dev, "Registered sensor subdevice: %s\n",
-		  subdev->name);
+/*
+ * bridge_init_async_subdevs() - Initialize bridge subdevices and async_subdevs in
+ *			      mx6s_csi_dev device. Both DT and platform data parsing use
+ *			      this routine.
+ *
+ * Returns 0 for success, -ENOMEM for failure.
+ */
+static int bridge_init_async_subdevs(struct mx6s_csi_dev *csi_dev, unsigned int n_sd)
+{
+	/* Reserve memory for 'n_sd' bridge_subdev descriptors. */
+	csi_dev->subdevs = devm_kcalloc(csi_dev->dev, n_sd,
+				       sizeof(*csi_dev->subdevs), GFP_KERNEL);
+	if (!csi_dev->subdevs)
+		return -ENOMEM;
+
+	/*
+	 * Reserve memory for 'n_sd' pointers to async_subdevices.
+	 * ceudev->asds members will point to &ceu_subdev.asd
+	 */
+	csi_dev->asds = devm_kcalloc(csi_dev->dev, n_sd,
+				    sizeof(*csi_dev->asds), GFP_KERNEL);
+	if (!csi_dev->asds)
+		return -ENOMEM;
+
+	csi_dev->sd = NULL;
+	csi_dev->sd_index = 0;
+	csi_dev->num_sd = 0;
 
 	return 0;
 }
 
+static int mx6sx_register_subdevs(struct mx6s_csi_dev *csi_dev)
+{
+	struct device_node *of = csi_dev->dev->of_node;
+	struct bridge_subdev *bridge_sd;
+	struct device_node *ep, *remote;
+	unsigned int i;
+	int num_ep, ret;
+
+	num_ep = of_graph_get_endpoint_count(of);
+	printk("num_ep: %d\n", num_ep);
+	if (!num_ep)
+		return -ENODEV;
+
+	ret = bridge_init_async_subdevs(csi_dev, num_ep);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < num_ep; i++) {
+		ep = of_graph_get_endpoint_by_regs(of, 0, i);
+		printk("mx6sx_register_subdevs ep->name: %s\n", ep->name);
+		if (!ep) {
+			dev_err(csi_dev->dev,
+				"No subdevice connected on endpoint %u.\n", i);
+			ret = -ENODEV;
+			goto error_put_node;
+		}
+
+		/* Setup the bridge subdevice and the async subdevice. */
+		bridge_sd = &csi_dev->subdevs[i];
+
+		INIT_LIST_HEAD(&bridge_sd->asd.list);
+
+		remote = of_graph_get_remote_port_parent(ep);
+		printk("mx6sx_register_subdevs remote->name: %s\n", remote->name);
+		bridge_sd->asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
+		bridge_sd->asd.match.fwnode.fwnode = of_fwnode_handle(remote);
+
+		csi_dev->asds[i] = &bridge_sd->asd;
+		
+		of_node_put(ep);
+
+	}
+
+	csi_dev->notifier.v4l2_dev	= &csi_dev->v4l2_dev;
+	csi_dev->notifier.subdevs	= csi_dev->asds;
+	csi_dev->notifier.num_subdevs	= num_ep;
+	csi_dev->notifier.bound		= bridge_notify_bound;
+	ret = v4l2_async_notifier_register(&csi_dev->v4l2_dev,
+					   &csi_dev->notifier);
+
+	if (ret)
+		dev_err(csi_dev->dev,
+					"Error register async notifier.\n");
+
+	return ret;
+
+error_put_node:
+	of_node_put(ep);
+	return ret;
+}
+
 static int mx6s_csi_mode_sel(struct mx6s_csi_dev *csi_dev)
 {
 	struct device_node *np = csi_dev->dev->of_node;
@@ -1795,51 +1883,6 @@ static int mx6s_csi_two_8bit_sensor_mode_sel(struct mx6s_csi_dev *csi_dev)
 	return 0;
 }
 
-static int mx6sx_register_subdevs(struct mx6s_csi_dev *csi_dev)
-{
-	struct device_node *parent = csi_dev->dev->of_node;
-	struct device_node *node, *port, *rem;
-	int ret;
-
-	/* Attach sensors linked to csi receivers */
-	for_each_available_child_of_node(parent, node) {
-		if (of_node_cmp(node->name, "port"))
-			continue;
-
-		/* The csi node can have only port subnode. */
-		port = of_get_next_child(node, NULL);
-		if (!port)
-			continue;
-		rem = of_graph_get_remote_port_parent(port);
-		of_node_put(port);
-		if (rem == NULL) {
-			v4l2_info(&csi_dev->v4l2_dev,
-						"Remote device at %s not found\n",
-						port->full_name);
-			return -1;
-		}
-
-		csi_dev->asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
-		csi_dev->asd.match.fwnode.fwnode = of_fwnode_handle(rem);
-		csi_dev->async_subdevs[0] = &csi_dev->asd;
-
-		of_node_put(rem);
-		break;
-	}
-
-	csi_dev->subdev_notifier.subdevs = csi_dev->async_subdevs;
-	csi_dev->subdev_notifier.num_subdevs = 1;
-	csi_dev->subdev_notifier.bound = subdev_notifier_bound;
-
-	ret = v4l2_async_notifier_register(&csi_dev->v4l2_dev,
-					&csi_dev->subdev_notifier);
-	if (ret)
-		dev_err(csi_dev->dev,
-					"Error register async notifier regoster\n");
-
-	return ret;
-}
-
 static int mx6s_csi_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -1848,6 +1891,7 @@ static int mx6s_csi_probe(struct platform_device *pdev)
 	struct video_device *vdev;
 	struct resource *res;
 	int ret = 0;
+	struct v4l2_ctrl_handler *hdl;
 
 	dev_dbg(dev, "initialising\n");
 
@@ -1939,6 +1983,16 @@ static int mx6s_csi_probe(struct platform_device *pdev)
 	video_set_drvdata(csi_dev->vdev, csi_dev);
 	mutex_lock(&csi_dev->lock);
 
+	/* Add the controls */
+	hdl = &csi_dev->ctrl_handler;
+	v4l2_ctrl_handler_init(hdl, 10);
+
+	if (hdl->error) {
+	ret = hdl->error;
+	goto free_hdl;
+	}
+	csi_dev->v4l2_dev.ctrl_handler = hdl;
+
 	ret = video_register_device(csi_dev->vdev, VFL_TYPE_GRABBER, -1);
 	if (ret < 0) {
 		video_device_release(csi_dev->vdev);
@@ -1964,6 +2018,8 @@ static int mx6s_csi_probe(struct platform_device *pdev)
 	pm_runtime_enable(csi_dev->dev);
 	return 0;
 
+free_hdl:
+   v4l2_ctrl_handler_free(&csi_dev->ctrl_handler);
 err_irq:
 	video_unregister_device(csi_dev->vdev);
 err_vdev:
@@ -1977,7 +2033,7 @@ static int mx6s_csi_remove(struct platform_device *pdev)
 	struct mx6s_csi_dev *csi_dev =
 				container_of(v4l2_dev, struct mx6s_csi_dev, v4l2_dev);
 
-	v4l2_async_notifier_unregister(&csi_dev->subdev_notifier);
+	v4l2_async_notifier_unregister(&csi_dev->notifier);
 
 	video_unregister_device(csi_dev->vdev);
 	v4l2_device_unregister(&csi_dev->v4l2_dev);
-- 
2.17.0

